# 计算机组成原理

## 计算机系统概述

### 计算机系统简介

#### 计算机系统

计算机系统由**硬件**和**软件**两大部分组成

![image-20230623125741365](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623125741365.png)

#### 计算机软硬件机器

微程序机器M0、实际机器M1 归属于硬件 ；虚拟机M2、M3、M4归属于软件

![image-20230622094955297](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622094955297.png) 

#### 计算机体系结构和计算机组成区别

计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理等）类似定义接口的概念

计算机组成：实现计算机系统结构所体现的属性（具体指令的实现）类似接口实现的概念

举例说明：一台机器是否具有某一项功能是计算机体系结构的问题，以至于这项功能是怎么实现得就是计算机组成的问题



### 计算机的基本组成

#### 冯.诺伊曼计算机的特点

1、五大部件组成（控制器、运算器、存储器、输入设备、输出设备）

2、指令和数据以相同的地位存储在存储器中，可按地址进行寻访

3、指令由操作码和地址码组成

4、指令和数据以二进制的形式表示

5、以运算器为中心

6、指令在存储器内按顺序存放

#### 存储器的基本组成

主要介绍存储体、存储器地址寄存器 MAR、存储器数据寄存器 MDR

![image-20230622150559063](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622150559063.png) 

#### 运算器的基本组成

主要介绍算数逻辑运算单元 ALU、累加器 ACC、乘商寄存器 MQ、操作数寄存器 X

![image-20230622132557894](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622132557894.png) 

#### 控制器的基本组成

主要介绍控制单元 CU、程序计数器 PC、指令寄存器 IR

![image-20230622135326640](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622135326640.png)

#### 主机完成一条指令的过程

**以取数指令为例**

指令包含两部分：一个是指令码（决定进行什么操作，比如是取数操作）；另一个是地址码（存放数据的地址）

步骤1：取**取数指令**到指令寄存器 IR （绿线）

![image-20230622142251410](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622142251410.png) 

步骤2：分析指令码以及执行指令操作（红线）

![image-20230622143704305](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622143704305.png) 

**以存数指令为例**

步骤1：取**存数指令**到指令寄存器 IR （如上图取取数指令步骤1）

步骤2：分析指令码以及执行指令操作（橙线）

![image-20230622144324986](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622144324986.png) 



### 计算机硬件的主要技术指标

![image-20230622150434734](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230622150434734.png)



## 计算机发展及应用

 略



## 系统总线

### 总线的基本概念

总线是连接各个部件的信息传输线，是各个部件共享的传输介质。（注意：在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息）

**为什么会出现总线？**

- 分散式设计的需求

  分散式设计体现在各个部件需要升级以及迭代发展，如果需要将这些部件统一起来或者说连接起来，就产生了总线的概念

- 标准化和模块化

  为了降低成本和提高生产效率，计算机制造商开始寻求一种标准化方法来连接不同的硬件组件

- IBM的早期贡献

  在20世纪70年代，IBM在其大型计算机系统中引入了系统总线的概念。特别是IBM System/360系列，它们使用了标准化总线来连接CPU、内存和I/O设备，这标志着系统总线在商业计算机中的广泛应用

在随后的系统总线中快速发展并不断的演变，从 ISA总线到 EISA、VESA 总线，再到 PCI总线，系统总线的速度和带宽不断提高，支持更多的设备和更复杂的系统

### 总线的分类

总线的分类标准有很多，比如按照数据传送方式来分，可以分成串行和并行，或者按照总线的使用范围分等等，接下来让我们按照连接的部件不同，分成三类总线

主要分为三部分，分别是片内总线、系统总线、通信总线

![image-20240123215955319](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240123215955319.png)

**注意点**

- 注意区别**总线和系统总线**之间的概念和范围等等的区别

  - 定义：

    ​	总线：总线是一种用于在计算机内部或计算机与外部设备之间传输数据的通信链路。它可以包含数据线、地址线和控制线。总线可以是并行或串行的，可以是单向或双向的，并且可以用于传输各种类型的信息。
    ​	系统总线：系统总线是连接计算机主要组件（如CPU、内存和I/O设备）的内部总线。它是计算机内部数据传输的主要通道，通常包括数据总线、地址总线和控制总线

  - 范围和功能：

    ​	总线：这个术语更广泛，可以指任何类型的通信链路，包括但不限于系统总线、I/O总线、内部总线、外部总线等。
    ​        系统总线：它是特定于计算机内部的一种总线，主要负责CPU和内存之间的数据传输，以及CPU与其他系统组件的通信。

  - 应用场景：

    ​	总线：广泛应用于各种电子设备中，不仅限于计算机，还可以用于嵌入式系统、通信设备等。
    ​        系统总线：专用于计算机内部，是构建计算机系统的核心部分。

- 通信总线中，串行和并行通信的数据传送速率都与距离成反比，并行通信适宜于近距离的数据传输（通常小于30m）；串行通信适宜于远距离传送，可以从几米达数千公里



### 总线特性及性能指标

​	总线是计算机系统中的一种通信机制，它允许不同组件（如CPU、内存、外设等）之间进行数据传输。总线的特性及性能指标是衡量其效率、可靠性和适用性的重要参数。以下是一些主要的总线特性和性能指标：

#### 总线特性

1. **并行与串行**：
   - 并行总线：多个数据位同时传输，提高了数据传输速率。
   - 串行总线：数据位逐个传输，通常用于较长距离的通信。
2. **宽度**：总线的宽度决定了可以同时传输的数据位数。例如，16位总线可以一次性传输16位数据
3. **速度**：总线的速度通常以时钟速率（MHz）来衡量，它决定了总线每秒可以传输多少个数据周期
4. **数据传输模式**：
   - 同步传输：数据传输在时钟信号的同步下进行。
   - 异步传输：数据传输不依赖于时钟信号，而是使用握手协议。
5. **总线仲裁**：总线仲裁决定了多个设备请求使用总线时的优先级和处理机制
6. **可扩展性**：总线是否支持扩展，以便连接更多的设备
7. **热插拔**：总线是否支持在不关闭系统的情况下添加或移除设备

#### 性能指标

1. **带宽**：单位时间内可以传输的最大数据量，通常以每秒位数（bps）或兆比特每秒（Mbps）来衡量
2. **传输速率**：数据通过总线的实际速度，受总线类型、宽度、时钟速率等因素影响
3. **延迟**：数据从源头传输到目的地所需的时间，包括传输延迟和仲裁延迟
4. **吞吐量**：单位时间内总线实际传输的数据量，通常受到带宽和延迟的限制
5. **错误率**：总线在数据传输过程中发生错误的频率
6. **可靠性**：总线在长时间运行中的稳定性，以及是否能够容忍错误
7. **兼容性**：总线是否支持不同类型和版本的设备

#### 总线标准（了解） 

​	总线标准是计算机行业中的一种规范，它定义了硬件设备之间如何进行通信和连接。制定总线标准的目的是为了便于机器的扩充和新设备的添加，同时确保不同厂商生产的硬件设备具有兼容性和互换性。以下是一些常见的总线标准：

1. ISA 总线：1984年，IBM公司为推出PC/AT机而建立的系统总线标准。支持64K I/O地址空间、16M主存地址空间的寻址，以及15级硬中断和7级DMA通道
2. EISA 总线：在ISA总线基础上进行扩展，提供了更多的功能和性能
3. MCA 总线：1987年，IBM公司推出的一种局部总线标准，具有较高的性能和带宽
4. VESA 局部总线：1992年，VESA组织推出的一种高性能局部总线，主要应用于图形加速卡
5. PCI 总线：1993年，英特尔、微软、Compaq等公司共同制定的一种局部总线标准，具有即插即用、高性能等特点，广泛应用于现代计算机系统中
6. AGP 总线：1996年，英特尔推出的一种专门用于图形加速卡的局部总线，以提高显示性能
7. USB 总线：1996年，英特尔、微软、Compaq等公司共同制定的一种外部总线标准，具有即插即用、热插拔等特点，广泛应用于各种外设连接



### 总线的结构

总线结构通常可分为单总线结构和多总线结构两种

#### 单总线结构框图

##### 概述

将CPU、主存、I/O设备都挂在一组总线上，允许 I/O设备之间、I/O设备与CPU、主存之间直接交换信息

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623102817881.png" alt="image-20230623102817881" style="zoom:80%;" /> 

##### 单总线的利弊分析

- **优势**：结构简便，便于扩充 I/O接口和设备
- **劣势**：不允许两个设备同时和 CPU 进行数据传输，将会严重影响系统的工作效率

**根本问题**：数据传输速率不匹配，CPU 和 I/O 设备 、主存的传输速度不匹配，因此出现了多总线结构如下	

---

#### 面向 CPU 的双总线结构框架图

##### 概述

为了提高数据处理能力和系统的扩展性，设计了两条独立的总线，通常分为前端总线和后端总线

**前端总线**：

- 负责CPU与内存之间的数据传输
- 它的频率通常与CPU的外频相同，直接影响到CPU与内存之间的通信速度

**后端总线**：

- 负责连接低速外设，如USB、IDE、SATA等
- 处理一些外设的数据传输，以及一些系统管理功能

以下为简易示意图方便理解（M 总线类似前端总线 ； I/O 总线类似后端总线）

![image-20230623103202710](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623103202710.png) 

##### 面向 CPU 的双总线结构利弊

**优势**：

- **分离高速与低速传输**：通过前端和后端总线的分离，高速设备（如CPU和内存）与低速设备（如硬盘、USB设备）的通信被分开，减少了互相干扰，提高了系统整体性能
- **扩展性**：双总线结构允许系统设计者根据需要独立升级前端总线和后端总线的速度和带宽，提高了系统的扩展性

**劣势**：

- **复杂性**：双总线结构增加了系统设计的复杂性，需要更多的硬件组件，增加了成本和故障点
- **成本**：双总线结构需要额外的芯片和电路设计，这可能会提高整体成本

---

#### 面向存储器的双总线结构框架图

##### 概述

为了提高存储器访问效率和系统带宽，设计了两条独立的总线专门用于处理存储器相关的数据传输。其中一条总线用于处理CPU到内存的数据传输，另一条总线用于处理I/O设备到内存的数据传输。

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623103639873.png" alt="image-20230623103639873" style="zoom:80%;" /> 

面向存储器的双总线结构的利弊

**优势**：

- **并行处理**：CPU和I/O设备可以并行访问内存，提高了系统带宽和效率
- **提升I/O性能**：I/O设备可以直接访问内存，提高了I/O操作的速度

**劣势**：

- **成本**：双总线结构增加了系统设计的复杂性，可能导致成本上升
- **能耗和热量**：需要更多的布线可能意味着更高的能耗和热量产生

---

#### 双总线结构框架图

##### 概述

将速度较低的I/O设备从单总线上分离出来，形成主存总线与I/O总线分开的结构。CPU将一部分功能下放给通道，使其对I/O设备具有统一管理的功能，以完成外部设备与主存储器之间的数据传送

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623111828712.png" alt="image-20230623111828712" style="zoom:80%;" /> 

##### 传统微型计算机的总线结构示例

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240126223636538.png" alt="image-20240126223636538" style="zoom:80%;" /> 

---

#### 三总线结构框架图

![image-20230623113100642](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623113100642.png) 

---

#### 四总线结构框架图

为了进一步提高I/O设备的性能，使其更快地响应命令，又出现了四总线结构

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623113853232.png" alt="image-20230623113853232" style="zoom:80%;" /> 

##### PCI 总线结构示例

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240126224044530.png" alt="image-20240126224044530" style="zoom:80%;" /> 



### 总线的控制

主要包括判优控制（或称仲裁逻辑）和通信控制

#### 总线的判优控制

主要目的：决定在多个设备同时请求使用总线时，哪一个设备将获得总线的控制权

##### 集中式判优控制

###### 概述

- 一个专门的硬件单元（如总线控制器）负责决定哪个设备可以访问总线

- 集中式判优控制可以是静态的或动态的控制

  - 静态判优控制（如固定优先级）按照预定的优先级顺序来决定访问权限

  - 动态判优控制（如轮询或基于请求的优先级）则根据当前的请求情况动态调整优先级

###### 链式查询方式

**原理**：设备接口通过BR向总线控制部件发送请求（占用总线请求），BG通过链式方式查询第一个向总线控制部件发送请求的设备，该设备更新总线为忙并占用总线

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623131640902.png" alt="image-20230623131640902" style="zoom:80%;" /> 

**优点**：

- 通过一个“令牌”或者“标记”在设备间传递，确保每个设备都有机会获得总线访问权
- 实现相对简单，只需要一个逻辑令牌沿着设备链传递

**缺点**：

- 访问顺序固定，如果某个设备不需要立即访问总线，会造成总线资源的浪费
- 如果令牌传递中的某个设备故障，可能会影响整个总线系统的运行

###### 计数器定时查询方式

**原理**：总线控制部件中有计数器，如果 BR 中有设备向总线控制部件发送请求并且总线控制部件没有被占用的情况，则开启计数器，通过设备地址轮询查找每个设备的请求情况（该查询情况中与每条设备连接的线是并行的，相互之间不会受到影响）

![image-20230623131730293](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623131730293.png)

**优点**：

- 通过计数器值来选择下一个访问总线的设备，可以实现更公平的访问
- 可以根据系统的实时负载情况动态调整每个设备的访问概率

**缺点**：

- 实现起来比固定优先级和轮询复杂，需要额外的逻辑来维护和更新计数器值
- 由于计数器可能导致任何设备在任意时刻获得总线，实时性要求高的设备可能无法保证快速响应

###### 独立请求方式

**原理**：每个设备接口都有单独的 BG、BR线，当部分设备接口向总线控制部件发送请求时候，总线控制部件通过排队器来决定设备的优先级并作出快速的响应

![image-20230623132743458](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623132743458.png)

**优点**：

- 设备在需要时立即发出请求，无需等待，适用于实时性要求高的系统
- 每个设备根据自己的需要请求总线，不受其他设备的影响

**缺点**：

- 当多个设备同时请求总线时，需要额外的机制来解决冲突，如“最高优先级胜出”或“先请求先服务”
- 需要更复杂的控制逻辑来处理多个请求，并确保公平性和效率

###### 三种判空控制方式的简易对比

![image-20230623133719208](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230623133719208.png)

##### 分布式判优控制（了解）

###### 概述

分布式判优控制是一种在计算机网络或通信系统中使用的仲裁机制，其中仲裁逻辑分布在各个网络节点上，而不是集中在一个单一的位置

###### 优点

- 分布式判优可以减少中央控制单元的负担，提高系统的整体效率
- 节点可以快速做出本地决策，减少了通信延迟
- 即使某些节点出现故障，其他节点仍然可以继续工作

###### 缺点

- 多个节点可能同时请求访问共享资源，需要有效的冲突解决机制
- 设计和实现分布式判优控制比集中式判优更加复杂

###### 分布式判优示例

- **CSMA/CD**：在发送数据前先监听信道，如果信道忙则等待，如果检测到碰撞则停止发送并等待随机时间后重试
- **CSMA/CA**：类似于CSMA/CD，但增加了碰撞避免机制，例如在发送数据前先发送一个预约信号
- **Token Ring**：令牌在网络中传递，只有持有令牌的节点才能发送数据

---

#### 总线通信控制

**目的**：计算机系统中用于管理和协调通过总线（一种用于传输数据的通信链路）的数据传输的技术。在多设备系统中，总线通信控制至关重要，因为它确保了数据的有效传输，同时避免了冲突和数据丢失 => 总的来说，解决通信双方 **协调配合** 问题

##### 总线的传输周期

- 申请分配阶段：  主模块申请，总线仲裁决定
- 寻址阶段：  主模块向从模块给出地址和指令
- 传数阶段：  主模块和从模块进行数据交换
- 结束阶段：  主模块撤销相关的信息

##### 总线通信的四种方式

- 同步通信：  由**统一时标**控制数据传送
- 异步通信（不互锁、半互锁、全互锁）：  采用**应答方式**，没有公共时钟标准
- 半同步通信：  同步、异步结合（允许不同传输速度的主从模块传输数据）
- 分离式通信：  充分挖掘系统总线每个瞬间的潜力

######  同步通信

- **同步式数据输入**

  T1：主模块发地址 ； T2：主模块发读命令 ；T3：从模块提供数据 ；T4 ：主模块撤销读命令，从模块撤销数据

  ![image-20240127155222134](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127155222134.png) 

- **同步式数据输出**（类似输入）

  ![image-20240127155504357](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127155504357.png) 

- **同步通信的利弊**

  - 规定明确、统一，模块间的配合简单一致
  - 主、从模块时间配合属于强制性“同步”，必须在限定时间内完成规定的要求。并且对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而言，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏灵活性

###### 异步通信

**概述**

异步通信是一种数据传输方式，在这种方式中，发送方和接收方不需要以相同的时钟速率或同步方式操作（允许各模块的速度不一致）

异步通信中的应答方式用于确认消息的接收，以确保通信的可靠性。根据确认机制的不同，可以分为以下三种类型：

![image-20240127160320673](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127160320673.png) 

- **不互锁**

  - 在这种模式下，发送方在发送消息后不会等待接收方的任何确认。发送方可以立即继续发送其他消息，而无需关心接收方是否已经成功接收 （）
  - 这种方式的优点是传输速度快，因为它不需要等待确认，但缺点是缺乏可靠性，因为发送方不知道消息是否已经被接收

- **半互锁**

  - 半互锁方式是介于不互锁和全互锁之间的一种模式。发送方在发送消息后会等待一个短时间窗口，如果在这段时间内接收到接收方的确认，则继续执行下一个任务；如果没有收到确认，发送方可能会重发消息或采取其他措施
  - 这种方式提高了可靠性，但仍然允许发送方在一定时间内继续执行其他任务，从而提高了效率

  **注意**：半互锁这个术语在不同的上下文中可能有不同的含义，有时它指的是发送方在等待确认时可以执行其他操作，但不会发送新的消息

- **全互锁**

  - 在全互锁模式下，发送方在发送消息后会完全阻塞，直到接收到接收方的确认。只有当确认被接收到后，发送方才会继续发送后续的消息
  - 这种方式提供了最高的可靠性，因为它确保每个消息都被接收方正确处理。但这也可能导致发送方的资源在等待确认时被浪费，降低了系统的整体效率

**适用的场景**

- **不互锁**：适用于对实时性要求较高的场合，例如，在实时操作系统或视频流传输中，可以容忍一定程度的丢包
- **半互锁**：适用于对可靠性有一定要求，但同时也需要保持通信效率的场合，如大多数网络通信
- **全互锁**：适用于对数据可靠性要求极高的场合，如金融交易、文件传输等，即使牺牲一些效率也要确保数据的完整性

###### 半同步通信

**概述**

结合了同步通信和异步通信的特点。传输的一部分是同步的，而另一部分则是异步的

以半同步通信数据输入为例（起始同步，中间等待异步）

- T1：主模块发出地址信息
- T2： 主模块发出命令
- Tw：当WAIT为低电平时，也就是进入等待（也就是异步情况）
- T3：从模块提供数据
- T4：主模块撤销读命令，从模块撤销数据

![image-20240127161109345](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127161109345.png) 

###### 分离式通信

**概述**

它允许发送方和接收方在时间和空间上解耦。在这种通信模型中，消息的生产者和消费者不必直接相互知晓，也不必同时在线或实时交互。分离式通信常用于分布式系统、异步处理和消息队列场景中

**传输周期**（只有单方向的信息流）

- 子周期1：主模块申请占用总线后，将命令、地址以及其他有关信息发送到系统总线上，使用完后即放弃总线的使用权
- 子周期2：当从模块接收到请求信息，开始准备数据。当数据准备好之后，从模块申请占用总线后，将各种信息送至总线上，使用完后即放弃总线的使用权

**分离式通信特点**

- 各模块有权申请占用总线
- 采用同步方式通信，不等对方回答
- 各模块准备数据时，不占用总线
- 总线被占用时，无空闲

**分离式通信的应用场景**

- **分布式系统**：在分布式系统中，不同的服务可能运行在不同的机器上，分离式通信有助于这些服务之间的解耦合
- **事件驱动架构**：在事件驱动的系统中，事件生产者发布事件到中央消息总线，而事件消费者订阅它们感兴趣的事件
- **后台处理**：对于耗时的后台任务，如视频转码、数据分析等，可以通过分离式通信将任务放入队列中，由后台工作线程异步处理



## 存储器

### 概述

存储器是计算机系统中的记忆设备，用来存放程序和数据

#### 存储器分类

存储器分类主要按照存储介质、存储方式以及计算机中的作用来进行分类

![存储器分类](https://use-typora.oss-cn-hangzhou.aliyuncs.com/%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB.png) 

#### 存储器的层次结构

从速度、容量以及价格三个性能指标来分析存储器

![image-20230701164422221](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230701164422221.png) 



### 主存储器

#### 概述

主存储器简称主存，是计算机硬件的一个重要部件。它的主要作用是存放指令和数据，并能由中央处理器（CPU）直接随机存取

##### 主存储器的组成

**MAR 寻址操作**

根据 MAR 中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元

**MDR 数据读入写出操作**

- 读出时，需经过读出放大器，才能将被选中单元的存储字送到 MDR
- 写入时，MDR 中的数据也必须经过写入电路才能真正写入到被选中的单元中

![image-20230701144921253](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230701144921253.png) 

##### 主存和cpu之间的联系

![image-20230701145349731](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230701145349731.png) 

##### 主存中存储单元地址的分配

主存储器被划分为许多存储单元，每个存储单元都有一个唯一的地址

主存中存储单元地址的分配还涉及到字节顺序的问题，即大端模式和小端模式；现在假设用每个存储字32位来存储 12345678H 数据

**大端大尾方式**：高位字节地址为字地址

| 字地址 | 字节地址（8位） | 字节地址 | 字节地址 | 字节地址 |
| :----: | :-------------: | :------: | :------: | :------: |
|   0    |       12        |    34    |    56    |    78    |
|   4    |                 |          |          |          |
|   8    |                 |          |          |          |

**小端小尾方式**：低位字节地址为字地址

| 字地址 | 字节地址 | 字节地址 | 字节地址 | 字节地址 |
| :----: | :------: | :------: | :------: | :------: |
|   0    |    78    |    56    |    34    |    12    |
|   4    |          |          |          |          |
|   8    |          |          |          |          |

##### 主存中的技术指标

主存的主要技术指标是**存储容量**和**存储速度**

![image-20240203154827366](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240203154827366.png) 

#### 半导体存储芯片

##### 基本结构

译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对被选中单元的读/写操作

![image-20230701154234737](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230701154234737.png) 

地址线是单向输入的，数据线是双向的，他们的位数与芯片容量有关

| 地址线（单向） | 数据线（双向） |  芯片容量  |
| :------------: | :------------: | :--------: |
|       10       |       4        | 2^10 * 4位 |
|       14       |       1        | 2^14 * 1位 |
|       13       |       8        | 2^13 * 8位 |

##### 译码驱动方式

译码驱动方式有两种：线选法和重合法

**线选法**

线选法是一种直接寻址方式，其中每个存储单元由一个独特的地址线组合直接选中。在这种方法中，每个存储单元或者其对应的存储位都有一个专用的选择线

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240204123850680.png" alt="image-20240204123850680" style="zoom:80%;" />  

**重合法**

重合法是一种寻址技术，它通过减少地址线的数量来实现更高效的存储器寻址。在这种方法中，地址线被复用，即同一组地址线在不同的时间阶段用于传递不同的地址信息

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240204123916776.png" alt="image-20240204123916776" style="zoom:80%;" />  

在实际的存储器设计中，通常会根据存储器的容量、性能要求、成本和功耗等因素来选择合适的寻址方法。重合法在**较高密度**的存储器设计中更为常见，因为它可以更有效地利用地址线资源。而线选法则在一些**对速度要求较高或者存储容量较小**的应用中更为合适



#### 随机存取存储器（RAM）

##### 静态RAM（SRAM）

存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路

###### 静态RAM基本电路

- 存储器：T1-T4 ；行开关：T5 - T6 ； 列开关：T7 - T8 （T5 - T8 都属于晶体管）
- 位线 A 为触发器原端、位线 A`为触发器非端（A 取反）

**读写操作**

- 读操作：置行地址、列地址有效，触发器 A 电平会通过 T6、T8 最后通过读出放大器进行读出
- 写操作：置行地址、列地址有效，电平会从 Din 写入，会先取反，然后通过 T5 - T8，将数据保存到触发器中

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240204184814323.png" alt="image-20240204184814323" style="zoom:67%;" />  

##### 动态RAM（DRAM）

###### 动态RAM 基本单元电路

概述：靠电容存储电荷的原理来寄存信息。若电容上存在足够多的电荷表示存“1”，电容上无电荷表示存“0”

- 三管 MOS

  - 读出时，先对预充电管T4置一预充电信号，使读数据线达到高电平VDD。然后由读选择线打开T2，若*T1的极间电容Cg*存有足够电荷（被认为原存“1”），使T1导通，则因T2、T1接地，使读数据线降为零电平，读出“0”信息；若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，读出线的高低电平可以区分“1”和“0”，且**读出与原存信息相反**
  - 写入时，将写信号加到写数据线上，然后由写数据线打开T3，这样，Cg便能随输入信息充电（写“1”）或放电（写“2”），且**写入与输入信息相同**

  ![image-20230708100116477](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230708100116477.png) 

- 单管 MOS

  - 读出时，字线上的高电平使T接通，若Cs有电荷，视为“1”；若Cs无电荷，视为“0”。（读出结束时，Cs中电荷释放完毕，所以为破坏性读出，必须再生）
  - 写入时，字线上的高电平使T接通，若数据线为高电平，经过T对Cs充电，使其存“1”；若数据线为低电平，Cs经T放电，使其存“0”

  ![image-20230708100421878](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230708100421878.png) 

###### 动态RAM刷新（刷新与行地址有关）

刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程；再生周期就是在一定的时间内，对动态 RAM 的全部基本单元电路作一次刷新操作

- **集中式刷新**（存取周期为 0.5 微秒，刷新周期为 2 毫秒）

  以128 × 128为例：

  ![image-20230708104909430](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230708104909430.png) 

  死区：0.5μs×128=64μs0.5μs×128 = 64μs （死区就是不能进行读写操作的时间）

  死时间率：为= 128/4000×100 = 3.2%

- **分散刷新**（存取周期为 1 微秒，刷新周期为 2 毫秒）

  以128 × 128为例：

  ![image-20230708104959905](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230708104959905.png) 

  优点：没有死区

- **异步刷新**（分散刷新与集中刷新相结合）

  以128 × 128为例（若每隔**约15.6μs**刷新一行）：

  ![image-20230708105454013](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230708105454013.png) 

  每行每隔 2ms 刷新一次 ；死区为 0.5μs

  优点：将刷新安排在指令译码阶段，不会出现“死区”问题

##### 静态RAM VS 动态RAM

DRAM（动态RAM）常用于做主存；SRAM（静态RAM）常用于做缓存

|          | DRAM |  SRAM  |
| :------: | :--: | :----: |
| 存储原理 | 电容 | 触发器 |
|  集成度  |  高  |   低   |
| 芯片引脚 |  少  |   多   |
|   功耗   |  小  |   大   |
|   价格   |  低  |   高   |
|   速度   |  慢  |   快   |
|   刷新   |  有  |   无   |



#### 只读存储器（ROM）

初衷是一旦注入原始信息就不能再改变了，但是随着市场的需要，希望能改变原来的数据，便出现了后续可以修改数据的只读存储器

##### 发展历程

- 早期的只读存储器——由厂家写内容 MROM
- 改进1——用户可以自己写（一次性） PROM
- 改进2——可以多次写（要能对信息进行擦除） EPROM
- 改进3——电可擦写（特定设备）
- 改进4——电可擦写（直接连接到计算机）

##### 掩模ROM（MROM）

一种只读存储器，它在制造过程中被编程，并且一旦编程完毕，其内容就无法再次修改

**实现原理**：通过行地址以及列地址来确定输出哪个位置的数据，然后通过是否存在 MOS 管来决定输出的数据是 0 还是 1，最后通过放大器输出

- 行列选择交叉处有MOS管为 “1”
- 行列选择交叉处无MOS管为 “0”

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240205124938265.png" alt="image-20240205124938265" style="zoom:67%;" /> 

##### PROM（一次性编程）

PROM是可以实现一次性编程的只读存储器

**实现原理**：通过熔丝是否熔断来进行判断 0 还是 1，但是熔断之后无法再恢复，所以只能让用户实现一次编程

- 熔丝断：“0”
- 熔丝未断：“1”

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240205125529757.png" alt="image-20240205125529757" style="zoom: 33%;" /><img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240205125205796.png" alt="image-20240205125205796" style="zoom:75%;" />  

##### EPROM（多次性编程）

EPROM是一种可擦除可编程只读存储器

N型沟道浮动栅MOS电路（利用紫外线进行擦除）

- D端加正电压 —— 形成浮动栅 —— S与D不导通为 “0”
- D端不加正电压 —— 不形成浮动栅 —— S与D导通为 “1”

![image-20230708111429530](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230708111429530.png) 

注意：如果需要重置数据，可用紫外线照射的方式驱散浮动栅

##### EEPROM（多次性编程）

一种可以在电子设备中使用多次的存储器芯片。它允许数据被多次编程和擦除，而不需要从电路板上移除芯片

- **多次编程**：EEPROM可以被重新编程多次，这使得它非常适合存储需要定期更新的数据，如配置设置或设备固件
- **非易失性**：EEPROM在断电后仍能保留数据，这是因为它使用浮栅晶体管技术来存储电荷，从而保持数据状态
- **擦除和编程速度**：EEPROM的擦除和编程速度相对较慢，通常比EPROM慢，但比Flash存储器快
- **有限的生命周期**：尽管EEPROM可以多次编程和擦除，但它有一个有限的擦除/编程周期。通常，一个EEPROM芯片可以承受数十万到数百万次的编程

##### Flash Memory（闪速型存储器）

一种非易失性存储技术，它可以在电力供应的情况下快速擦除和编程

##### EPROM、EEPROM 、Flash Memory 三者区别

- EPROM —— 价格便宜，集成度高，可编程只读存储器，需要紫外线照射来擦除，不支持多次编程
- EEPROM —— 电可擦洗重写，允许数据被多次编程和擦除
- Flash Memory —— 支持更快速的擦除和编程操作，通常用于更大的存储容量，如USB驱动器和固态硬盘



#### 存储器与CPU的连接

##### 存储器容量的扩展

- **位扩展**

  用 **2片 **1K × 4位存储芯片组成1K × 8位的存储器

  地址线 A0 - A9 ；数据线拼接成 D0 - D7 

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240205142329938.png" alt="image-20240205142329938" style="zoom:67%;" />  

- **字扩展**

  用 **2片 **1K × 8位存储芯片组成2K × 8位的存储器

  A10 决定是存储在哪个存储芯片里

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240205143356978.png" alt="image-20240205143356978" style="zoom:67%;" />  

- **字、位扩展**

  用 **8片** 1K × 4位存储芯片组成4K × 8位的存储器

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240205144000499.png" alt="image-20240205144000499" style="zoom:67%;" />  

##### 存储器与CPU的连接

- 地址线的连接：通常总是将CPU地址线的低位与存储芯片的地址线相连。CPU地址线的高位或在存储芯片扩充时用或做其他用途
- 数据线的连接：存在线数量不同的情况，此时必须对存储芯片扩位，使其数据位数和 CPU 的数据线数相同
- 读/写命令线的连接：一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写
- 片选线的连接
- 合理选择存储芯片：主要是指存储芯片类型(RAM或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序等等；RAM则是为用户编程而设置的
- 其他（时序、负载等）



#### 存储器的校验

在计算机运行过程中，由于种种原因致使数据在存储过程中可能出现差错。为了能及时发现错误并及时纠正错误，通常可将原数据配成汉明编码。

**合法代码集合**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/20190505220024616.png" alt="img" style="zoom:80%;" /> 

任意两组合法代码之间二进制位数的最小差异编码的纠错、检错能力与编码的最小距离有关

> L - 1 = D + C (D >= C)
>
> - L：编码的最小距离
> - D：检错的位数
> - C：纠错的位数

**具体编码实例 - 海明码**

码距：又叫海明距离，是在信息编码中，两个编码之间对应位上编码不同的位数。例如编码100110和010101，第1、2、5、6位都不相同，所以这两个编码的码距就是4，并且可以通过异或的方式求出（异或后计算零的个数）

两个合法编码（码字）

工作流程

1. 确定校验码位数 r

   - 数据/信息位数为 m
   - 校验码位数为 r
   - **2 ^ r >= m + r + 1** (已知 m + r 的和，可以通过整个公式分别求出 m、r)

2. 确定校验码和数据的位置

   假设需要校验数据为 1100，意味着 m  = 4,可以通过公式求得，r 的最小值为 3

3. 求出校验码的值

   根据偶校验可以得出如下（分三组，分别是：xx1、x1x、1xx）

   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |
   | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   |  1   |  1   |  0   |  x4  |  0   |  x2  |  x1  |
   |      |      |      |  0   |      |  0   |  1   |

   海明码就是 1100001

4. 检错并纠错

   假设最后传入的参数为 1100000

   计算该海明码的三组校验是否正确

   x1 0 0 0 1

   x2 0 0 1 1    =>   可知 x1 校验错误  0 0 1 说明最小位出错了，但是恰好是校验码出错，可以不用纠错

   x4 0 0 1 1



#### 提高访存速度的措施

不仅可以采用高速器件、层次结构 Cache - 主存，还可以调整主存结构的方式来提高访存的速度，如下就是调整主存结构的方式

- **单体多字系统**

  前提：程序和数据在存储体内是连续存放的，这样就可以在一个存取周期内从同一地址中取出4条指令，然后逐条送至 CPU 中执行<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230716134022603.png" alt="image-20230716134022603" style="zoom:67%;" /> 

  存在的问题：

  - 若只需向存储体写入16位数据（单字长），而数据寄存器却多读出了48位，若想让这48位不存入存储体，会增加寄存器的复杂性
  - 若需要取出的数据（或指令）不是连续的，必然会使数据寄存器取出无用的数据

- **多体并行系统**（顺序编址）

  采用多体模块组成的存储器，主要应用于存储器容量的扩展（高位地址可表示体号，低位地址为体内地址）![image-20230716133951483](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230716133951483.png) 

  存在的问题：

  - 某个存储体可能会非常繁忙，其余存储体空闲
  - 这种方式主要适用于存储器容量的扩展，并不适合提高存储器的带宽

- **低位交叉**（各个体轮流编址）

  主要应用于存储器的带宽和访问速度的提高（低位地址可表示体号，高位地址为体内地址）![image-20230716134241076](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230716134241076.png) 

  低位交叉的特点：

  - 在不改变存储周期的前提下，增加存储器的带宽


  **注意对体号和体内地址的理解**

  - 物理地址：物理地址也称为"体号"，是指在计算机系统中实际存在的存储器单元的地址。物理地址是硬件直接访问主存储器的地址，它对应于存储器芯片或者其他存储介质上的真实地址
  - 虚拟地址：虚拟地址也称为"体内地址"，是指程序中使用的地址，它由程序生成并由操作系统进行地址转换。虚拟地址空间是程序员能够访问的抽象地址空间，程序中的变量和数据都是相对于虚拟地址空间来说的

- 高性能存储芯片（了解）

  - SDRAM
  - RDRAM
  - 带 Cache 的 DRAM



### 高速缓冲存储器 

####  概述

目的：避免CPU**空等**现象

原理：程序访问的局部性原理（指令和数据在主存地址分布不是随机的，而是相对的簇聚，也就是说程序大部分访问都是少数的指令和数据）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230722101550637.png" alt="image-20230722101550637" style="zoom:67%;" /> 

---

#### Cache 工作原理

**主存和缓存的编址**

- 主存和缓存按块存储，块的大小相同（B 就是块的大小）
- Cache 内的块内地址不仅大小和主存一样，而且取值也是一样的 
- Cache 内的标记就是来记录主存的主存块号

![image-20230722101645431](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230722101645431.png) 		

**命中与未命中**

缓存共有 C 块，主存共有 M 块（M >> C）

- 命中：CPU 所要访问的数据已经从主存储器映射到了 Cache 缓存中（用标记建立起与主存的关系）
- 未命中：CPU 所要访问的数据没有在 Cache 缓存中找到
- 命中率 h：CPU欲访问的信息在 Cache 中的比率（与 Cache 的容量和块长有关）
- 访问效率 e：tc / (h * tc + (1-h) * (tm + tc)) * 100% （区间：[tc / tm ,1]）  （访问 Cache 的时间 tc ； 访问主存的时间 tm）

**示例详解**

假设 CPU 执行某段程序时，共访问 Cache 命中3000次，访问主存 20 次。已知 Cache的存取周期为50ns,主存的存取周期为200ns，求Cache-主存系统的命中率、访问效率和平均访问时间？

- 命中率 =  命中 Cache 的次数 / 总次数 = 3000 / (3000+20) 
- 平均访问时间 = Cache的存取周期 * 命中率 +  （1 - 命中率） * 主存的存取周期 = 50ns * h + (1-h) * 200ns
- 访问效率 e = 访问 Cache 的时间  / 平均访问时间 * 100%  = 50ns /  50ns * h + (1-h) * 200ns

---

#### Cache 的基本结构

**Cache 的基本结构原理框图**

CPU（通过**地址总线**）给出地址，这个地址包括**（主存）块号**和**块内地址**。块内地址直接传给Cache，使用块号在**主存Cache地址映像机构**中确认**是否命中**。如果发生命中，得到Cache的块号；如果未命中，查看Cache中**是否有空间可装入主存块**。若有，访问主存装入Cache；若没有，启用**Cache替换机构**，根据替换算法，决定Cache中哪块可以被替换，然后**访问主存替换Cache**即可

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240220123818397.png" alt=" " style="zoom:67%;" /> 

它主要由Cache存储体、地址映射变换机构、Cache替换机构几大模块组成

- Cache存储体

  Cache存储体**以块为单位**与主存交换信息，为加速Cache与主存之间的调动，主存大多采用多体结构，且Cache访存的优先级最高

- 地址映射变换机构

  地址映射变换机构是将CPU送来的主存地址转换为Cache地址

- Cache替换机构

  当Cache内容已满，无法接受来自主存块的信息时，就由Cache内的替换机构按一定的替换算法来确定应从Cache内移出哪个块返回主存，而把新的主存块调入Cache

- Cache的读写操作

  - 读操作

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240220124748964.png" alt="image-20240220124748964" style="zoom:50%;" />  

  - 写操作

    - 写直达

      写操作数据既写入Cache 又写入主存；写操作时间就是访问主存的时间

    - 写回法

      写操作只把数据写入到 Cache 缓存而不写入主存；当 Cache 写入的数据要被替换的时候才写入主存


注意：Cache 对用户来说是透明的

---

#### Cache 的改进 

**Cache 的改进框图** 

![image-20230722112226441](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230722112226441.png) 

片内缓存：也称单一缓存，是指在CPU和主存之间只设一个缓存

- 片内缓存与CPU之间的数据通路很短，大大提高了存取速度，外部总线又可更多地支持I/O设备与主存的信息传输，增强了系统的整体效率
- 可是，由于片内缓存在芯片内，其容量不可能很大，这就可能致使CPU欲访问的信息不在缓存内，势必通过系统总线访问主存，访问次数多了，整机速度就会下降

片外缓存：也称二级缓存，由比主存动态RAM和ROM存取速度更快的静态RAM组成

统一缓存和分立缓存的选取主要考虑两个因素：

- 与主存结构有关。如果计算机的主存是统一的（指令和数据存储在统一主存中），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存
- 与指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般采用分立缓存（所谓超前控制，是指在当前指令执行过程尚未结束时就提前将下一条准备执行的指令取出）

---

#### Cache - 主存的地址映射

由主存地址映射到Cache地址称为地址映射。地址映射方式很多，有直接映射、全相联映射、组相联映射三种

##### 直接映射

- 每个缓存块 i 可以和若干个主存块对应
- 每个主存块 j 只能和一个缓存块对应

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240220223000655.png" alt="image-20240220223000655" style="zoom:67%;" /> 

**说明**：

- 主存字块标记（区号）：将主存分成 2 的 t 次方倍的 Cache 大小，也就是 t 的位数取决于 主存 / Cache 的大小

- Cache 字块地址（块号）：主存每个区都会对应字块 2 的 c 次方块数，Cache中也会有对应的块号与之一一对应，只要区号和块号都一致，就可以知道Cache中是否有该数据

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230722132835714.png" alt="image-20230722132835714" style="zoom:50%;" /> 

**优点**：实现简单，只需利用主存地址的某些位直接判断，就可确定所需字块是否在缓存中

**缺点**：不够灵活，因每个内存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率

##### 全相联映射

允许主存中每一字块映射到Cache中的任何一块位置上

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240220223725460.png" alt="image-20240220223725460" style="zoom:67%;" /> 

**优点**：灵活，命中率高，缩短了块冲突率。

**缺点**：

- 主存字块标记需要与Cache的所有标记进行**同时**比较，电路会非常复杂。
- 主存字块标记从t位增加到t+c位，这就使Cache”标记“的位数增多，比较器的长度就会增长。

##### 组相联映射

组相联映射是对直接映射和全相联映射的一种折中

i = j mod Q  （某一主存块 j 按模 Q 映射到缓存的第 i 组中的任一块）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240220224232200.png" alt="image-20240220224232200" style="zoom:67%;" /> 

**说明**：主存的字块号对应了 Cache 的组数，Cache 的组数决定可以主存相同块号同时放入 Cache 中的数量

**优点**

1. **减少了冲突失效**：与直接映射相比，组相联映射通过将主存块映射到一组而不是单一的缓存块，减少了因为多个频繁访问的内存块映射到同一个缓存块而产生的冲突失效（冲突失效是指不同的内存块需要映射到同一个缓存块）
2. **简化了替换策略**：由于一个组内有多个块可供选择替换，因此替换策略（如最少使用替换或随机替换）的实施比全相联映射简单，因为它只需在组内进行选择，而不是在整个缓存中进行选择
3. **灵活性和适应性**：组相联映射可以根据缓存的大小和设计，调整组的大小，从而提供更好的性能和适应性
4. **成本适中**：与全相联映射相比，组相联映射在硬件实现上的成本更低，因为它不需要在整个缓存中搜索可替换的块

**缺点**

1. **硬件复杂性**：尽管组相联映射的硬件复杂性低于全相联映射，但它仍然比直接映射复杂，因为它需要额外的硬件来识别和选择组内的缓存块
2. **有限的并行度**：组相联映射的并行度低于全相联映射，因为它仍然存在一定程度的冲突失效，这限制了并行访问缓存的能力

##### 例题详集

**例题 1：直接映射**

假设有一个Cache，容量为16KB，块大小为4字节，使用直接映射技术。主存地址为32位。求：

1. Cache中有多少个块？
2. Cache的索引位数是多少？
3. 主存中的一个特定地址0x0000A5F8会被映射到Cache的哪个块？

**解答**

1. Cache的总块数 = Cache容量 / 块大小 = 16KB / 4B = 4096个块
2. Cache的索引位数 = log2(总块数) = log2(4096) = 12位
3. 对于直接映射，Cache的索引部分直接由主存地址的中间部分给出（忽略最低的块偏移量和最高的主存标记位）。假设Cache的起始地址为0，那么地址0x0000A5F8的索引部分是A5F8的后12位，即0xA5F8的最低12位，所以索引是0x5F8。这个索引值将指定Cache中的相应块

**例题 2：组相联映射**

假设有一个Cache，容量为32KB，块大小为8字节，使用2路组相联映射技术。主存地址为32位。求：

1. Cache中有多少个块？
2. Cache的组数是多少？
3. 主存地址0x00012345会被映射到Cache的哪个组？

**解答**

1. Cache的总块数 = Cache容量 / 块大小 = 32KB / 8B = 4096个块
2. 由于是2路组相联映射，每个组包含2个块，所以组数 = 总块数 / 每组的块数 = 4096 / 2 = 2048组
3. 对于组相联映射，Cache的索引位数 = log2(组数) = log2(2048) = 11位。地址0x00012345的索引部分是中间的11位，即0x12345的最低11位，所以索引是0x345。这个索引值将指定Cache中的相应组

**例题 3：全相联映射**

假设有一个Cache，容量为8KB，块大小为16字节，使用全相联映射技术。主存地址为32位。求：

1. Cache中有多少个块？
2. 主存地址0x00005678会被映射到Cache中的哪个块（假设使用最少使用替换策略）？

**解答**

1. Cache的总块数 = Cache容量 / 块大小 = 8KB / 16B = 512个块
2. 对于全相联映射，不需要索引位，因为Cache中的任何块都可以映射到任何一个地址。但是，替换策略（在这个例子中最少使用）决定了哪个块将被替换。地址0x00005678映射到Cache中的哪个块取决于当前的Cache状态和替换策略。全相联映射没有固定的映射规则，需要额外的硬件来跟踪每个块的使用情况

---

#### 替换算法

##### 先进先出（FIFO）算法

选择最早调入Cache的字块进行替换，它不需要记录各字块的使用情况

- 优点：比较容易实现，开销小
- 缺点：没有根据访存的局部性原理，故不能提高 Cache 的命中率

##### 近期最少使用（LRU）算法

LRU算法比较好地利用访存局部性原理，替换出近期用得最少的字块。它需要随时记录 Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。

优点：它实际是一种推测的方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间，LRU算法的平均命中率比FIFO的高



### 辅助存储器（了解）

#### 概述

辅助存储器，也称为外部存储器或第二存储器，是计算机系统中用于长期存储大量数据和程序的设备，与主存储器（RAM）相对。辅助存储器不像主存储器那样直接由CPU访问，但其存储容量通常要大得多，而且数据在断电后仍然可以保持

![image-20230722135011004](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230722135011004.png) 

- **记录密度**：它决定了磁盘上可以存储多少数据位（磁带存储器则用位密度表示；磁盘沿半径方向单位长度的磁道数为道密度）
- **存储容量**：硬盘的存储容量主要由磁盘的数量、磁盘的尺寸以及存储密度决定
- **平均寻址时间**：包括寻道时间和等待时间。寻道时间是磁头移动到正确磁道的时间，等待时间是磁头等待所需数据旋转到磁头下方的时间
- **数据传输速率**：受限于磁盘的旋转速度和磁头的读写能力（记录密度 Db；记录介质的运动速度 V）
- **误码率**：通常与存储介质的品质、磁头的技术以及读写过程的准确性有关

---

#### 磁记录原理

##### 概述

磁记录原理是利用磁性的变化来存储和读取数据的技术。在磁记录中，信息被转换成电信号，这些电信号通过磁头产生变化的磁场，进而改变磁记录介质（如磁带或硬盘）上的磁化方向，以此来记录数据

本质就是利用磁体的南北极来对应二进制的 0 和 1

##### 写入（记录）过程

- 输入信息首先被转换成电信号
- 这些电信号通过磁头线圈产生磁场
- 当磁场强度足够大，能够克服磁介质的矫顽力时，磁介质表面会产生磁化区域
- 磁化区域的方向（北极指向南极）代表二进制信息中的一个位（0或1）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240221182502228.png" alt="image-20240221182502228" style="zoom:80%;" />  

##### 读取（再现）过程

- 磁头移动到磁化区域上方，磁介质的磁化状态会影响磁头的磁场
- 这种变化被转换成电信号，通过放大和处理，恢复成原始的输入信息

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240221182522647.png" alt="image-20240221182522647" style="zoom: 67%;" /> 

总的来说，磁记录是一种成熟且广泛应用的存储技术，它通过改变磁性材料表面的磁化方向来存储和读取数字信息

---

#### 硬磁盘存储器

##### 概述

硬磁盘存储器是一种利用磁记录技术进行数据存储的辅助存储设备。它由一个或多个快速旋转的磁盘（盘片）组成，每个磁盘表面都涂有一层磁性材料。硬磁盘存储器通过磁头在磁盘表面读写数据，这些磁头悬浮在磁盘表面非常小的距离上，不会与磁盘表面直接接触

##### 硬磁盘存储器的类型

- 固定磁头和移动磁头

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240221183158043.png" alt="image-20240221183158043" style="zoom:50%;" />   

- 可换盘和固定盘（可换盘片指盘片可以脱机保存；固定盘磁盘存储器是指磁盘不能从驱动器中取下，更换时要把整个头盘组合体一起更换）

##### 硬磁盘储存器的结构

硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片3大部分组成

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240221183435766.png" alt="image-20240221183435766" style="zoom:67%;" /> 

- **磁盘驱动器**：这是硬磁盘存储器的核心部件，负责控制磁头的移动以及磁盘的旋转。它通常包括磁头组件、盘片组件、电机和控制器等
- **磁盘**：磁盘是硬磁盘存储器的数据存储介质，通常由一个或多个铝或玻璃制成的盘片组成。每个盘片都涂有一层磁性材料，用于存储数据
- **磁头**：磁头是硬磁盘存储器中读取和写入数据的关键部件。它通常安装在磁头臂上，可以精确地移动到磁盘的指定位置进行读写操作
- **硬盘控制器**：硬盘控制器是硬盘存储器和计算机主板之间的接口，负责管理数据传输和磁盘操作。常见的硬盘控制器标准有IDE、SCSI、SATA等

**磁盘驱动器**

磁盘驱动器是主机外的一个独立装置，又称磁盘机，主要包括主轴、定位驱动及数据控制等3部分

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240221183604478.png" alt="image-20240221183604478" style="zoom:67%;" /> 

**磁盘控制器**

磁盘控制器通常制作成一块电路板，插在主机总线插槽中

**作用**：接收由主机发来的命令，将它转换成磁盘驱动器的控制命令，实现主机和驱动器之间的数据格式转换和数据传送，并控制驱动器的读/写

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240221183954078.png" alt="image-20240221183954078" style="zoom:67%;" /> 

**磁盘控制器是主机与磁盘驱动器之间的接口**

- 接收主机发来的命令，转换成磁盘驱动器的控制命令
- 实现主机和驱动器之间的数据格式转换
- 控制磁盘驱动器读写

**盘片**

由硬质铝合金材料制成

---

#### 软磁盘存储器

##### 概述

软磁盘存储器与硬磁盘存储器的存储原理和记录方式是相同的，但在结构上有较大的区别

|      |           硬盘           |       软盘       |
| :--: | :----------------------: | :--------------: |
| 速度 |            高            |        低        |
| 磁头 |    固定、活动（浮动）    | 活动（接触盘片） |
| 盘片 | 固定盘、盘组大部分不可换 |     可换盘片     |
| 价格 |            高            |        低        |
| 环境 |           苛刻           |      不苛刻      |

##### 软盘片

是一种已经较为过时的存储介质，它由一个柔软的磁性圆盘封装在一个方形或圆形的保护套中。软盘片在个人电脑和计算机历史上曾广泛使用，但因其有限的存储容量和相对较慢的数据传输速度，已经被更高效的大容量存储设备所取代

**软盘片的工作原理**：

软盘片的工作原理与硬磁盘驱动器类似，都是利用磁性材料记录数据。软盘片的数据存储在磁盘的磁性涂层上，通过改变磁性的方向来表示二进制数据（0和1）。读写数据时，软盘驱动器中的磁头会接触（或非常接近）磁盘表面的磁性涂层，进行数据的读取或写入。

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230722140035392.png" alt=" " style="zoom:67%;" /> 

---

#### 光盘存储器

##### 概述

是一种使用光学技术来读取和写入数据的存储设备。光盘存储器利用激光束在光盘表面形成的小凹槽（即“坑”）来存储信息。这些凹槽代表二进制数据，通过激光读取凹槽的反射差异来识别数据

- 采用光存储技术 —- 利用激光写入和读出
- 第一代光存储技术 —- 采用非磁性介质 — 不可擦写
- 第二代光存储技术 —- 采用磁性介质 — 可擦写

##### 光盘存储器的工作原理

- **写入数据**：在可写或可重写光盘上，激光束会加热光盘表面的特殊染料或相变材料，使其融化或改变相位，形成凹槽
- **读取数据**：读取数据时，激光束照射在光盘表面，当激光遇到凹槽时，反射率会发生变化，光传感器检测到这些变化并将其转换为电信号，进而解码为数字数据

##### 光盘的存储原理

- 只读型和只写一次型 — 热作用（物理或化学）
- 可擦写光盘 — 热磁效应



## 输入输出系统

### 概述

#### 发展概况

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230729101215386.png" alt="image-20230729101215386" style="zoom:67%;" /> 

- 早期阶段：I/O 设备与主存交换信息都必须通过CPU

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240305192647669.png" alt="image-20240305192647669" style="zoom:67%;" /> 

- 接口模块和DMA阶段：I/O 设备通过接口模块与主机连接，计算机系统采用了总线结构

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240305192747364.png" alt="image-20240305192747364" style="zoom:67%;" /> 

- 具有通道结构的阶段：依赖通道管理的I/O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240305192958854.png" alt="image-20240305192958854" style="zoom:67%;" /> 

- 具有I/O处理机的阶段：它基本独立于主机工作，既可完成I/O通道要完成的I/O控制，又可完成码制变换、格式处理、数据块检错、纠错等操作，具有I/O处理机的输入输出系统与CPU工作的并行 

---

#### 输入输出系统的组成

##### I/O软件

- **I/O指令**（机器指令的一种）

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240305213658314.png" alt="image-20240305213658314" style="zoom:80%;" /> 

  - 操作码字段可作为I/O指令与其他指令（如访存指令、算逻指令、控制指令等）的判别代码
  - 命令码体现I/O设备的具体操作
  - I/O指令的设备码相当于设备的地址

- **通道指令**（通道自身的指令）

  对具有通道的I/O系统专门设置的指令，这类指令一般指出数据组的首地址、传送字数、操作命令

- **上述两者的区别**

  - 通道指令是通道自身的指令，用来执行I/O操作，如读、写、磁带走带及磁盘找道等
  - 而I/O指令是CPU指令系统的一部分，是CPU用来控制输入输出操作的指令，由CPU译码后执行

##### I/O硬件（了解）

计算机系统中用于与外部设备进行数据传输的物理设备。这些硬件组件使得计算机能够与用户、存储设备、网络以及其他计算机进行交互

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240305215323815.png" alt="image-20240305215323815" style="zoom:67%;" /> 

---

#### I/O 设备和主机的联系方式

##### I/O 设备编址方式

- 统一编制（用取数、存数指令）

  统一编址就是将 I/O 地址看做是存储器地址的一部分

- 不统一编址（有专门的 I/O 指令）

  指 I/O 地址和存储器地址是分开的，所有对 I/O设备的访问必须有专用的 I/O 指令

显然统一编址占用了存储空间，减少了主存容量，但无须专用的 I/O 指令。不统一编址由于不占用主存空间，故不影响主存容量，但需设 I/O 专用指令

##### 设备寻址

用**设备选择电路**识别是否被选中

##### 传送方式

- 串行：若在同一瞬间只传送一位信息，在不同时刻连续逐位传送一串信息
- 并行：在同一瞬间，n 位信息同时从CPU输出至 I/O 设备

##### 联络方式

- 立即响应：主要事对于一些工作速度十分缓慢的 I/O 设备，当他们与 CPU 发生联系的时候，通过都已经处于等待的状态，只要 CPU 的 I/O 指令一到就会立即响应

- 异步工作采用应答信号

  主要应对一些 I/O 设备与主机工作速度不匹配的时候，通常采用异步工作方式

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307191401796.png" alt="image-20240307191401796" style="zoom:67%;" />    

- 同步工作采用同步时标联络：同步工作要求 I/O 设备与 CPU 的工作速度完全同步

---

#### I/O设备与主机的连接方式

##### 辐射式连接

采用辐射式连接方式时，要求每台 I/O 设备都有一套控制线路和一组信号线，因此所用的器件和连线较多，对 I/O 设备的增删都比较困难（计算机发展的初级阶段）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307191538732.png" alt="image-20240307191538732" style="zoom:80%;" />  

##### 总线连接

通过一组总线（包括地址线、数据线、控制线等)，将所有的 I/O 设备与主机连接（现代大多数计算机系统所采用的方式）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307191826286.png" alt="image-20240307191826286" style="zoom:50%;" /> 

----

#### I/O设备与主机信息传送的控制方式

I/O 设备与主机交换信息时，共有5种控制方式：程序查询方式、程序中断方式、直接存储器存取方式(DMA)、I/O 通道方式、I/O 处理机方式

##### 程序查询方式

程序查询方式是由CPU通过程序不断查询 I/O 设备是否已做好雅备，从而控制 I/O 设备与主机交换信息

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307192200730.png" alt="image-20240307192200730" style="zoom:67%;" />  

缺少：CPU 和 I/O 处于串行传输，CPU 的工作效率不高

##### 程序中断方式

徜若CPU在启动I/O设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当I/O设备准备就绪并向CPU发出中断请求后才予以响应，这将大大提高CPU的工作效率

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307192323662.png" alt="image-20240307192323662" style="zoom:70%;" /> <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307192348234.png" alt="image-20240307192348234" style="zoom:120%;" />  

##### DMA方式

在DMA方式中，主存与 I/O 设备之间有一条数据通路，主存与 I/O 设备交换信息时，无须调用中断服务程序。若出现 DMA 和 CPU 同时访问主存，CPU 总是将总线占有权让给 DMA,通常把 DMA 的这种占有称为窃取或挪用。窃取的时间一般为一个存取周期，故又把DMA占用的存取周期窃取周期或挪用周期

而且，在DMA窃取存取周期时，CPU尚能继续作内部操作（如乘法运算）。可见，与程序查询和程序中断方式相比，DMA方式进一步提高了CPU的资源利用率 

##### 三种方式区别示意图

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307222642509.png" alt="image-20240307222642509" style="zoom:80%;" />   



### I/O设备

#### 概述

中央处理器和主存构成了主机，除主机外的大部分硬件设备都可称为 I/O 设备或外部设备，或外围设备，简称外设

**I/O设备的结构框图**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307223150047.png" alt="image-20240307223150047" style="zoom:80%;" />  

**外部设备大致分三类**

- 人机交互设备：能将人体五官可识别的信息和机器可识别的信息相互转换的（如键盘、鼠标、扫描仪、摄像机、语音识别器等）
- 计算机信息存储设备：系统软件和各种计算机的有用信息，其信息量极大，需存储保留起来（如磁盘、光盘、磁带等等）
- 机-机通信设备：用来实现一台计算机与其他计算机或与其他系统之间完成通信任务的设备（如调制解调器等等）

---

#### 输入设备（了解）

- 键盘：用于输入文本和命令
- 鼠标：用于导航和选择屏幕上的项目
- 触摸屏：允许用户通过直接触摸屏幕来与计算机交互
- 扫描仪：用于将物理文档转换成数字格式
- 摄像头：捕捉图像和视频
- 条形码阅读器：读取条形码并将其转换成数字信息
- 数码化仪：如图形板，用于绘制和输入图形 

#### 输出设备（了解）

- 显示器：显示计算机生成的图像和文本
- 打印机：将计算机生成的文档打印成纸质形式
- 音响设备：播放计算机产生的声音
- 投影仪：将计算机屏幕上的内容投射到其他平面上

#### 其他 I/O 设备（了解）

计算机的I/O设备中有一类既是输入设备，又是输出设备

- 磁盘驱动器：包括硬盘驱动器和固态驱动器，用于存储和检索数据
- USB闪存驱动器：便携式存储设备，用于数据传输
- 网络接口卡：用于连接到计算机网络，实现数据的发送和接收
- 读卡器：读取各种类型的存储卡，如SD卡、CF卡等 



### I/O接口

#### 概述

I/O 接口通常是指主机与 I/O 设备之间设置的一个硬件电路及其相应的软件控制

**为啥要设置接口？**

- 实现设备的选择
- 实现数据缓冲达到速度匹配
- 实现数据串-并格式转换
- 实现电平转换
- 传送控制命令
- 反映设备的状态（忙、等待、中断请求）

---

#### 接口的功能和组成

##### 总线连接方式的 I/O 接口电路

每一台 I/O 设备都是通过 I/O 接口挂到系统总线上的

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240308182822136.png" alt="image-20240308182822136" style="zoom:80%;" />  

补充：I/O 总线包括数据线、设备选择线、命令线以及状态线

- **数据线**：数据线是 I/O 设备与主机之间数据代码的传送线，其根数一般等于存储字长的位数或字符的位数，它通常是双向的，也可以是单向的
- **设备选择线**：设备选择线是用来传送设备码的，它的根数取决于 I/O 指令中设备码的位数。如果把设备码看做是地址号，那么设备选择线又可称为地址线
- **命令线**：命令线主要用以传输 CPU 向设备发出的各种命令信号，如启动、清除、屏蔽、读、写等
- **状态线**：状态线是将 I/O 设备的状态向主机报告的信号线，例如，设备是否准备就绪等等

##### 接口的功能和组成

​       **功能 **                                          **组成**

- 选址功能                                设备选择电路

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240308183615627.png" alt="image-20240308183615627" style="zoom:67%;" /> 

- 传送命令的功能                     命令寄存器、命令译码器

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240308183643390.png" alt="image-20240308183643390" style="zoom:67%;" /> 

- 传送数据的功能                     数据缓冲寄存器

- 反映设备状态的功能              设备状态标记（完成触发器 D  工作触发器 B  中断请求触发器 INTR  屏蔽触发器 MASK）

---

#### 接口类型

**I/O接口的基本组成**

1. 按数据传送方式分类，有并行接口和串行接口
   - 并行接口是将一个字节（或一个字）的所有位同时传送（如Intel8255)
   - 串行接口是在设备与接口间一位一位传送（如Intel8251)
2. 按功能选择的灵活性分类，有可编程接口和不可编程接口
   - 可编程接口的功能及操作方式可用程序来改变或选择（如Intel8255、Intel8251)
   - 不可编程接口不能由程序来改变其功能，但可通过硬连线逻辑来实现不同的功能（如Intel8212)
3. 按通用性分类有通用接口和专用接口
   - 通用接口可供多种I/O设备使用（如Intel8255、 Intel8212）
   - 专用接口是为某类外设或某种用途专门设计的（如Intel8279、Intel8275）
4. 按数据传送的控制方式分类，有程序型接口和DMA型接口
   - 程序型接口用于连接速度较慢的 I/O 设备，如显示终端、键盘、打印机等（如Intel8259）
   - DMA型接口用于连接高速 I/O 设备，如磁盘、磁带等（如Intel8257）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240308183849645.png" alt="image-20240308183849645" style="zoom:80%;" />  



### 程序查询方式

#### 程序查询流程

在程序查询方式中，CPU会通过查询程序不断地检查各个I/O设备是否准备好进行数据传输

- CPU初始化时，会在寄存器中设置好主存缓冲区的首地址和计数值
- CPU发出启动指令，启动所有需要的I/O设备
- CPU循环执行查询操作，从第一个设备开始，逐一检查每个设备是否准备就绪
- 如果某个设备准备好，CPU就发出传送指令，并与该设备进行数据传输
- 数据传输完成后，CPU可以返回到查询循环，继续检查下一个设备

**单/多个 I/O 设备的查询流程**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309100304089.png" alt="image-20240309100304089" style="zoom:70%;" />   <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309095444120.png" alt="image-20240309095444120" style="zoom: 80%;" />  

**缺点：**

- CPU在等待I/O设备准备就绪的过程中，会持续执行查询操作，这会导致CPU利用率低
- 如果多个设备同时准备好，程序查询方式无法有效地处理并行操作

---

#### 程序查询方式的接口电路

1. 当 CPU 通过 I/O 指令启动输入设备时，指令的设备码字段通过地址线送至设备选择电路
2. 若该接口的设备码与地址线上的代码吻合，其输出 SEL 有效
3. I/O 指令的启动命令经过“与非”门将工作触发器B置“1”，将完成触发器D置“0”
4. 由 B 触发器启动设备工作
5. 输入设备将数据送至数据缓冲寄存器
6. 由设备发设备工作结束信号，将 D 置“1”，B 置“0”，表示外设推备就绪
7. D 触发器以“准备就绪”状态通知CPU,表示“数据缓冲满”
8. CPU 执行输入指令，将数据缓冲寄存器中的数据送至 CPU 的通用寄存器，再存入主存相关单元

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309100703495.png" alt="image-20240309100703495" style="zoom:80%;" />  



### 程序中断方式

#### 中断的概念

程序中断方式是基于程序查询方式的改进，它允许I/O设备在准备好后主动中断CPU，而不是让CPU不断地查询

- CPU 初始化所有 I/O 设备，并允许它们通过中断请求线（IRQ）发起中断
- CPU 开始执行其他任务，不需要持续查询 I/O 设备状态
- 当某个 I/O 设备准备好数据传输时，它会通过中断请求线发送中断信号给 CPU
- CPU 响应中断，暂停当前任务，处理中断（即与请求的 I/O 设备进行数据传输）
- 数据传输完成后，CPU 恢复被中断的任务

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240307192323662.png" alt="image-20240307192323662" style="zoom:70%;" />  

**I/O 中断案例**

当打印机在准备数据以及打印前准备阶段，CPU 都会继续执行主程序，只有当打印机准备好之后才会发中断请求给 CPU ，然后 CPU 响应该中断

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309101148286.png" alt="image-20240309101148286" style="zoom:80%;" />  

**优点：**

- CPU的利用率提高，因为它不需要不断地执行查询循环，可以在等待 I/O 操作的同时执行其他任务
- 支持并行操作，多个设备可以独立地中断 CPU，不需要等待其他设备的处理

---

#### 程序中断方式的接口电路

- **中断请求触发器和中断屏蔽触发器**

  接口电路中的完成触发器 D、中断请求触发器 INTR、中断屏蔽触发器 MASK 和中断查询信号的关系如下图所示。可见，仅当设备准备就绪(D = 1),且该设备未被屏蔽(MASK =  0)时，CPU的中断查询信号可将中断请求触发器置“1” ( ‘ INTR = 1)

  ![image-20240309105343509](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309105343509.png) 	

- **排队器**

  当多个中断源同时向CPU提出请求时，CPU只能按中断源的不同性质对其排队，给予不同等级的优先权，并按优先等级的高低予以响应

  硬件排队器（优先级：从左到右依次降低，是用INTRn的非来控制右侧INTR(n+1)的输出）

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309105815830.png" alt="image-20240309105815830" style="zoom:80%;" />   

- **中断向量地址形成部件（设备编码器）**

  由硬件产生向量地址，再由向量地址找到入口地址

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309105908754.png" alt="image-20240309105908754" style="zoom:120%;" /> <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309105932237.png" alt="image-20240309105932237" style="zoom: 67%;" />

  中断向量地址形成部件的原理

   <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309110212852.png" alt="image-20240309110212852" style="zoom:67%;" /> 

- **程序中断方式接口电路的基本组成**

  1. **中断请求线（IRQ）**：设备使用中断请求线向 CPU 发送中断信号，表明它需要 CPU 的处理或者有数据准备好
  2. **中断控制器**：当有多个设备时，中断控制器负责管理多个中断请求，确定优先级，并将中断请求转发给 CPU
  3. **设备选择电路**：用于识别哪个设备请求中断，通常通过比较设备地址和 CPU 发出的地址来实现
  4. **设备忙/就绪状态触发器**：这些触发器用来指示设备是否忙（正在处理数据）或者就绪（数据准备好）
  5. **数据缓冲寄存器（DBR）**：当设备准备好数据后，数据被暂存到数据缓冲寄存器中，等待CPU读取
  6. **中断屏蔽寄存器（MASK）**：控制哪些中断请求被允许通过，哪些被屏蔽
  7. **中断处理程序**：CPU接收到中断请求后，执行的中断处理程序代码，用于响应设备请求
  8. **排队器**：当有多个中断请求同时发生时，排队器负责决定哪个请求优先被处理
  9. **设备编码器**：生成中断向量，这个向量指向特定的中断服务程序
  10. **中断向量地址形成部件**：用于生成中断向量的地址，这样CPU可以找到并执行正确的中断处理程序

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20230812113657078.png" alt="image-20230812113657078" style="zoom:67%;" /> 

---

#### I/O中断处理过程

**CPU响应中断的条件和时间**

- 条件： 允许中断触发器 EINT = 1
- 时间： 当 D = 1 且 MASK = 0 、 在每条指令执行阶段的结束前、 INTR 置 1

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309110715800.png" alt="image-20240309110715800" style="zoom:80%;" />  

----

#### 中断服务程序的流程

1. 保护现场
   - 程序断点的保护（中断隐指令完成）
   - 寄存器内容的保护 （出栈指令）
2. 中断服务：对不同的 I/O 设备具有不同内容的设备服务
3. 恢复现场（取数指令或者出栈指令）
4. 中断返回（中断返回指令） 

**单重中断和多重中断**

- 单重中断：不允许中断现行的中断服务程序
- 多重中断：允许级别更高的中断源来中断现行的中断服务程序

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309111314644.png" alt="image-20240309111314644" style="zoom:67%;" />  



### DMA 方式

#### 概述

**DMA 和程序中断方式的数据通路的区别？**

由于主存和DA接口之间有一条数据通路，因此主存和设备交换信息时，不通过CPU,也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式的工作速度高

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309112537127.png" alt="image-20240309112537127" style="zoom:80%;" />  

**DMA 方式和程序中断的比较**

|              |   中断方式   |   DMA方式    |
| :----------: | :----------: | :----------: |
|   数据传送   |     程序     |     硬件     |
|   响应时间   | 指令执行结束 | 存储周期结束 |
| 处理异常情况 |      能      |     不能     |
|   中断请求   |   传送数据   |    后处理    |
|    优先级    |      低      |      高      |

---

#### DMA 方式的功能和组成

##### 功能

- 向 CPU 申请 DMA 传送
- 处理总线的控制权的转交
- 管理系统总线、控制数据传送
- 确定数据传送的首地址和长度以及修正传送过程数据地址和长度
- DMA 传送结束时，给出操作完成信号

##### 组成

- **主存地址寄存器(AR)**：AR用于存放主存中需要交换数据的地址。在DMA传送数据前，必须通过程序将数据在主存中的首地址送到主存地址寄存器
- **字计数器(WC)**： WC用于记录传送数据的总字数，通常以交换字数的补码值预置。在DMA传送过程中，每传送一个字，字计数器如1，直到计数器为0，即最高位产生进位时，表示该批数据传送完毕
- **数据缓冲寄存器(BR)** ：BR用于暂存每次传送的数据
- **DMA控制逻辑** ：DMA控制逻辑负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成
- **中断机构**：当字计数器溢出（全“0”）时，表示一批数据交换完毕，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作 DMA操作的后处理
- **设备地址寄存器(DAR)** ：DAR存放I/O设备的设备码或表示设备信息存储区的寻址信息（如磁盘数据所在的区号、盘面号和柱面号）

<img src="C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20240309113820075.png" alt="image-20240309113820075" style="zoom:80%;" /> 

---

#### DMA 与主存交换数据的三种方式

- **停止 CPU 访问主存**

  控制建档，但是 CPU 处于半工作或保持状态，未充分发挥 CPU 对主存的利用率

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309113201248.png" alt="image-20240309113201248" style="zoom:80%;" />  

- **周期挪用（周期窃取）**

  每当 I/O 设备发出 DMA 请求时，I/O 设备便挪用或窃取总线占用权一个或几个主存周期，而 DMA 不请求时，CPU 仍继续访问主存，

  CPU 和 DMA 同时请求访存（此时将总线控制权让给DMA）

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309113217951.png" alt="image-20240309113217951" style="zoom:80%;" /> 

- **DMA 与 CPU 交替访问**

  CPU 工作周期分为 C1、C2，C1主要供DMA访存，C2主要供CPU访存

  不需要申请建立和归还总线的使用权

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309113241453.png" alt="image-20240309113241453" style="zoom:80%;" /> 

---

#### DMA 的工作过程

DMA 传送过程分：预处理、数据传送、后处理 

##### 预处理

- 给DMA控制逻辑指明数据传送方向
- 向DMA设备地址寄存器送人设备号，并启动设备
- 向DMA主存地址寄存器送入交换数据的主存起始地址
- 对字计数器赋予交换数据的个数

#####  数据传送

DMA方式是以数据块为单位传送的，以周期挪用的DMA方式为例

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309114505413.png" alt="image-20240309114505413" style="zoom: 50%;" /> <img src="C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20240309113820075.png" alt="image-20240309113820075" style="zoom: 60%;" /> 

##### 后处理

当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，做一些 DMA的结束工作

- 校验传送主存的数据是否正确
- 决定是否继续用 DMA 传送其他数据块，若继续传送，则又要对 DMA 接口进行初始化，若不需要传送，则停止外设
- 测试在传送过程中是否发生错误，若出错，则转错误诊断及处理错误程序

##### DMA 接口与系统的连接方式

- 具有公共请求线的DMA请求

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309114841499.png" alt="image-20240309114841499" style="zoom:80%;" />  

- 独立的 DMA 请求

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309114908072.png" alt="image-20240309114908072" style="zoom:80%;" /> 

---

#### DMA 接口的类型

- **选择型的 DMA 接口**

  在物理上连接多个设备；在逻辑上只允许连接一个设备

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309115047539.png" alt="image-20240309115047539" style="zoom:67%;" />  

- **多路型的 DMA 接口**

  在物理上连接多个设备；在逻辑上允许连接多个设备同时工作

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309115125111.png" alt="image-20240309115125111" style="zoom:67%;" />  

  多路型 DMA 接口的工作原理

  磁盘、磁带、打印机分别每隔30us、45us、150us向DMA接口发DMA请求，磁盘的优先级高于磁带，磁带的优先级高于打印机

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240309115201856.png" alt="image-20240309115201856" style="zoom:67%;" />  



## 计算机的运算方法

### 无符号数和有符号数

#### 概念

计算机中的数均放在寄存器中，通常称寄存器的位数为机器字长。所谓无符号数，即没有符号的数，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的

比如：以机器字长为16位为例，无符号数的表示范围为 0~65535，而有符号数的表示范围为  -32768 ~ +32767

---

#### 有符号数

##### 有符号数又分真值和机器数

有正负符号（+、-）就是真值，用数字表示符号的就是机器数

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312185640448.png" alt="image-20240312185640448" style="zoom:67%;" />  

---

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值，故原码表示又称为**带符号的绝对值表示**

**整数的原码定义（n 为数值位数）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312190056513.png" alt="image-20240312190056513" style="zoom:67%;" />  

**举例如下**

- 真值： x = +1110   [x]原 = 0,1110 (逗号是用来间隔符号和数值)
- 真值： x = -1110   [x]原 = 1,1110

**小数的原码定义**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312190201306.png" alt="image-20240312190201306" style="zoom:67%;" />  

**举例如下**

- 真值： x = +0.1110   [x]原 = 0,1110  (逗号是用来间隔符号和数值)
- 真值： x = -0.1110   [x]原 = 1,1110 

原码的特点是简单、直观，但是不易于进行加减法操作，引出补码

---

##### 补码表示法

易于进行加减法操作（原理：就好比时钟顺时针旋转90度和逆时针旋转270度是没有区别的，可以把减法运算变成加法运算来简化）

**整数的补码定义（n 为数值位数）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312190725110.png" alt="image-20240312190725110" style="zoom:80%;" />   

**举例如下**

- 真值： x = +1110   [x]原 = 0,1110  [x]补 = 0,1110  (逗号是用来间隔符号和数值)
- 真值： x = -1110   [x]原 = 1,1110   [x]补 = 1,0010（计算方式可以将 2^(n+1) 也就是这里的 100000，先进行减1操作，变成 11111 进行加 x 操作，最后加回 1，就好得到最终的结果）

**小数的补码定义**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312191511882.png" alt="image-20240312191511882" style="zoom:80%;" />  

**举例如下**

- 真值： x = +0.1110   [x]原 = 0,1110  [x]补 = 0,1110   (逗号是用来间隔符号和数值部分)
- 真值： x = -0.1110   [x]原 = 1,1110   [x]补 = 1,0010

**原码求补码的快捷方式**

- 当原码为正数时，补码和原码是一致的
- 当原码为负数时，补码可用原码（除符号位）每位都取反并末位加上1求得（补码转化成原码也是同样的规则）

----

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡

**整数的反码定义（n 为数值位数）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312191714052.png" alt="image-20240312191714052" style="zoom:67%;" />  

**举例如下** 

- 真值： x = +1110   [x]原 = 0,1110  [x]补 = 0,1110   [x]反 = 0,1110(逗号是用来间隔符号和整数数值)
- 真值： x = -1110   [x]原 = 1,1110   [x]补 = 1,0010  [x]反 = 1,0001

**小数的反码定义**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312191915009.png" alt="image-20240312191915009" style="zoom:80%;" />  

**举例如下**

- 真值： x = +0.1110   [x]原 = 0.1110  [x]补 = 0.1110  [x]反 = 0.1110
- 真值： x = -0.1110   [x]原 = 1.1110   [x]补 = 1.0010  [x]反 = 1.0001

 **练习题目**

```
x = +70   [x]原 = 0,1000110  [x]补 =  0,1000110
x = -70   [x]原 = 1,1000110  [x]补 =  1,0111010
x = +0.1110   [x]原 = 0.1110  [x]补 = 0.1110
x = -0.1110   [x]原 = 1.1110  [x]补 = 1.0010
x = +0.0000   [x]原 = 0.0000  [x]补 = 0.0000 [x]反 = 0.0000 
x = -0.0000   [x]原 = 1.0000  [x]补 = 0.0000（[+0]补 = [-0]补） [x]反 = 1.1111（[+0]反 != [-0]反）
x = -1.0000   [x]原 = 不能表示  [x]补 = 1.0000 （10.0000 - 1.0000）
```

##### 三种机器数的特点

- 三种机器数的最高位均为符号位。符号位和数值部分之间可用 “,” 隔开
- 当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同
- 当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“求反加1”，反码是原码的“每位求反”

----

##### 移码表示法

补码表示很难比较数字的大小

**整数的移码定义（x 为真值）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312192123253.png" alt="image-20240312192123253" style="zoom:50%;" /> 

**补码和移码之间的转换**

补码和移码就是符号之间取反，其他都是相同的

注意：移码标志中零也是唯一的



### 数的定点表示和浮点表示

在计算机中，小数点不用专门的器件表示，而是按约定的方式标出，共有两种方法表示小数点的存在，即定点表示和浮点表示

#### 定点表示

- 当小数点位于数符和第一数值位之间时，机器内的数为纯小数
- 当小数点位于数值位之后时，机器内的数为纯整数。
- 采用定点数的机器称为定点机
- 由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”

![image-20240316110035878](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316110035878.png)  、

**应用场景**：通常用于对精度要求不是特别高的计算，比如音频处理、简单的数值计算等

---

#### 浮点表示

浮点数即小数点的位置可以浮动的数（可以理解为科学计数法的引申）

**浮点数表示法：S 为尾数（可正可负），j 为阶码（可正可负），r 是基数（或基值）**

![image-20240316110737288](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316110737288.png) 

**浮点数转换示例**

![image-20240316111243257](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316111243257.png)  

**浮点数在机器中的形式如下所示**

采用这种数据格式的机器称为浮点机

- 阶码是整数，阶符和阶码的位数合起来反映浮点数的表示范围及小数点的实际位置
- 尾数是小数，其位数n反映了浮点数的精度
- 尾数的符号代表浮点数的正负

![image-20240316111339340](C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20240316111339340.png)   

**浮点数表示的范围**

以通式 N=S×r^j 为例，设浮点数阶码的数值位取 m 位，尾数的数值位取 n 位，当浮点数为非规格化数时，它在数轴上的表示范围如下

![image-20240316113449175](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316113449175.png) 

**浮点数的规格化形式**

- 基数 r = 2 尾数最高位为1
- 基数 r = 4 尾数最高2位为不全为0
- 基数 r = 8 尾数最高3位为不全为0

基数越大，可表示的浮点数的范围越大，但是浮点数的精度降低

**机械零**

- 当浮点数尾数为0时，不论其阶码为何值都当机械零处理
- 当浮点数阶码等于或者小于它所表示的最小数时，不论尾数为何值都当机械零处理

**应用场景**：适用于需要大范围数值表示和较高精度的场合，如科学计算、图形渲染等



### 定点运算

#### 移位运算

移位运算称为移位操作，对计算机来说，有很大的实用价值。例如，当某计算机没有乘（除）法运算线路时，可以采用移位和加法相结合，实现乘（除）运算

#### 算数移位规则

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240318191558049.png" alt="image-20240318191558049" style="zoom:67%;" /> 

**算术移位和逻辑移位的区别？**

本质区别：符号位是否参与运算

- 有符号数的移位称为算术移位
- 无符号数的移位称为逻辑移位

算术左移时，符号位移至C,最高数位就可避免移丢

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240318191834589.png" alt="image-20240318191834589" style="zoom:67%;" />  

#### 加法与减法运算

**补码加减运算的基本公式**

- 加法                                                                                                                

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124136519.png" alt=" " style="zoom: 67%;" />  

- 减法

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124200649.png" alt="image-20240319124200649" style="zoom:67%;" /> 

**举例**

已知 A = 0.1011，B = -0.0101，求[A+B]补

![image-20240319124328601](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124328601.png)  

**一位符号位溢出判断**

参加操作的两位数符号相同，但是相加或者相减得出符号不同的结果，即为溢出 

硬件实现：通过判断最高有效位 **异或** 符号位的进位 = 1 

**举例**

在这个例子中，两个正数相加，结果却得到了一个负数（符号位为1）。这是不可能的，因为两个正数相加的结果应该是正数。因此，我们可以判断发生了正溢出

```txt
  01111111  (第一个数)
+ 01111111  (第二个数)
  -----------
  10111110  (结果)
```

**二位符号位溢出判断**

结果的双符号位相同 未溢出，反之溢出 比如： 01.xxx ；10.xxxx (最高符号位代表其真实的符号)

![image-20240319124501376](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124501376.png)  

**举例**

在这个例子中，两个正数相加，结果的双符号位变成了01，这表示发生了正溢出。因为双符号位的第一位是0，表示原来的数值是正数，而第二位是1，表示发生了正溢出

```txt
  00 11111111 11111111  (第一个数)
+ 00 00000000 00000001  (第二个数)
  -------------------
  01 00000000 00000000  (结果)
```

---

#### 乘法运算

乘法运算可以用移位和加法来实现

**示例**

已知x = -0.1110  y = -0.1101，求[x·y]原 = 0.1011 0110（符号异或得到）		

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319125457391.png" alt="image-20240319125457391" style="zoom:67%;" /> 

---

#### 除法运算

##### 概述

**笔算除法和机器除法之间的区别**

|                笔算除法                 |                机器除法                |
| :-------------------------------------: | :------------------------------------: |
|              商符单独处理               |             符号位异或得出             |
|                心算上商                 | \|x\| - \|y\| > 0 上商 1 ，反之上商 0  |
| 余数不动，低位补 0 减去，右移一位的除数 |     余数左移一位低位补 0 减去除数      |
|     2 倍字长加法器，上商位置不固定      | 1 倍字长加法器，在寄存器的末尾进行上商 |

**原码的除法示例**

[x] 原 = x0 * x1 * x2 ... xn  （绝对值标记为 x*）

[y] 原 = y0 * y1 * y2 ... yn  （绝对值标记为 y*）

**约定**

- 小数定点除法 x* < y* => 反之溢出
- 整数定点除法 x* > y* => 反之溢出
- 被除数不能等于 0  => 异常
- 除数不能为 0 => 直接求得 0

##### 恢复余数法

恢复余数法的特点是：当余数（被除数）为负时，需加上除数，将其恢复成原来的余数。

案例如下：

已知 x = - 0.1011，y = -0.1101，求[x/y]原

![image-20231015112934573](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20231015112934573.png) 

##### 加减交替法（不恢复余数法）

**运算规则：**

- 余数 R > 0 上商 1，2R - y* (余数R左移一位，加上 [-y*])
- 余数 R < 0 上商 0，2R + y* (恢复余数R+y*，左移一位 2(R+y *) ，加上 [-y *] 得出 2R + y *)	

案例如下：

已知 x = - 0.1011，y = 0.1101，求[x/y]原

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20231015112840632.png" alt="image-20231015112840632"  /> 



### 浮点运算

#### 浮点数的加减运算

![ ](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185340146.png) 

**运算步骤**

- 对阶，使两数的小数点位置对齐。（小阶向大阶看齐）

- 尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）。

- 规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。

  - 左规：尾数左移一位，阶码减1，直到第一数位和数符不同为止
  - 右规：当尾数溢出时，需要尾数右移一位，阶码加1

- 舍入，为提高精度，要考虑尾数右移时丢失的数值位。

  - 0 舍 1 入法（“0舍1入”法类似于十进制数运算中的“四舍五人”法，即在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1）
  - 恒置 1 法（尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”）

- 溢出判断，即判断结果是否溢出

  ![ ](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185607917.png) 

#### 浮点数的乘除运算（略）



### 算术逻辑单元

#### ALU框图

图中 Ai 和 Bi 为输入变量；ki 为控制信号，ki 的不同取值可决定该电路作哪一种算术运算或哪一种逻辑运算；Fi 是输出函数。

![image-20240319185755884](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185755884.png) 

---

#### 并行加法器

并行加法器由若千个全加器组成

由于每位全加器的进位输出是高一位全加器的进位输入，因此当全加器有进位时，这种一级一级传递进位的过程将会大大影响运算速度

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185942199.png" alt="image-20240319185942199" style="zoom:80%;" />  

输入 Ai Bi 输出和为 Si 以及进位 Ci

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190016253.png" alt="image-20240319190016253" style="zoom:80%;" />  

---

#### 串行进位链

串行进位链是指并行加法器中的进位信号采用串行传递

![image-20240319190402109](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190402109.png) 

若设与非门的级延迟时间为ty，那么当di、ti形成后，共需8ty,便可产生最高位的进位。实际上每增加一位全加器，进位时间就会增加2ty，n位全加器的最长进位时间为2nty

---

#### 并行进位链

并行进位链是指并行加法器中的进位信号是同时产生的，又称先行进位、跳跃进位等

##### 单重分组跳跃进位

单重分组跳跃进位就是将位全加器分成若干小组，小组内的进位同时产生，小组与小组之间采用串行进位，这种进位又有组内并行、组间串行之称。

左边的是每组的逻辑电路，左边是串行的组（（小组内并行，小组间串行））

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190447719.png" alt="image-20240319190447719" style="zoom:50%;" /> <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190506553.png" alt="image-20240319190506553" style="zoom:67%;" /> 

---

##### 双重分组跳跃进位

将位全加器分成若干大组，每个大组中又包含若干小组，而每个大组内所包含的各个小组的最高位进位是同时产生的，大组与大组间采用串行进位。

32位并行加法器双重分组跳跃进位链框图（小组间并行，大组间串- 尾数是小数，其位数n反映了浮点数的精度

- 尾数的符号代表浮点数的正负行）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190538590.png" alt="image-20240319190538590" style="zoom:80%;" />  



## 指令系统

### 指令的概述

#### 指令的格式

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240322124839520.png" alt="image-20240322124839520" style="zoom:67%;" /> 

- 操作码：反映机器做什么操作

  - 长度固定：将操作码集中放在指令字的一个字段内（用于指令字段较长的情况。例如： IBM370）

  - 长度可变：操作码分散在指令字的不同字段中（有效地压缩操作码的平均长度，在字长较短的微型计算机中被广泛采用。例如：PDP-11）

  - 扩展操作码技术：操作码的位数随地址数的减少而增加

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240322125211160.png" alt="image-20240322125211160" style="zoom:50%;" /> 

- 地址码：地址码用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址  

  分类：四地址指令、三地址指令、二地址指令、一地址指令、零地址指令

#### 指令的字长取决于

- 操作码的长度
- 操作数地址的长度
- 操作数地址的个数

指令字长可以分为固定和可变：固定的时候，指令字长 = 存储字长 ； 可变的时候，按字节的整数倍数变化



### 操作数类型和操作种类

#### 操作数的类型

- 地址：无符号整数
- 数字：定点数、浮点数、十进制数
- 字符：ASCII
- 逻辑数：逻辑运算

#### 数据在存储器中的存放方式

- **不对准边界**（从任意位置开始访问）

  优点：不浪费存储资源

  缺点：除了访问每个字节之外，访问其他任何类型的数据都可能花费两个存储周期的时间；读写控制比较复杂

  ![image-20231113221113765](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20231113221113765.png) 

- **对准边界**（从一个存储字的起始位置开始访问）

  优点：无论访问任何类型的数据，在一个周期均可完成；读写控制简单

  缺点：浪费了宝贵的存储资源

  ![image-20231113221137383](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20231113221137383.png) 

- **边界对转方式**（从地址的整数倍位置开始访问）

  数据存放的起始位置是数据长度的整数倍（前面两种方式的折中方案）

#### 操作类型

- 数据传送：数据传送包括寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送
- 算术逻辑操作：算术运算和逻辑运算
- 移位操作：分为算术移位、逻辑移位和循环移位
- 转移：跳转、无条件/条件转移等
- 输入输出：从外设中的寄存器读入一个数据到 CPU 的寄存器内，或将数据从 CPU 的寄存器输出至某外设的寄存器中



### 寻址方式

寻址方式：确定本条指令的数据地址以及下一条将要执行的指令地址的方法

寻址方式分为指令寻址和数据寻址两大类

#### 指令寻址

- 顺序寻址可通过程序计数器PC加1，自动形成下一条指令的地址
- 跳跃寻址则通过转移类指令实现

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240326124133642.png" alt="image-20240326124133642" style="zoom:67%;" /> 

---

#### 数据寻址

指令的地址码字段通常都不代表操作数的真实地址

![image-20240326124748293](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240326124748293.png)  

- 形式地址：指令中的地址（可以理解为逻辑地址） 
- 有效地址：操作数的真实地址

以下寻址方式建立在 指令字长 = 存储字长 = 机器字长

---

##### 立即寻址

操作数本身设在指令字内，即形式地址 A 不是操作数的地址，而是操作数本身，又称之为立即数（数据是采用补码形式存放的）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240326124901358.png" alt="image-20240326124901358" style="zoom:67%;" />   

**优点**：只要取出指令，便可立即获得操作数，这种指令在执行阶段不必再访问存储器

**缺点**：显然 A 的位数限制了这类指令所能表述的立即数的范围

---

##### 直接寻址

EA = A 有效地址由形式地址直接给出

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240326125244468.png" alt="image-20240326125244468" style="zoom:67%;" />  

**优点**：寻找操作数比较简单，也不需要专门计算操作数的地址，在指令执行阶段对主存只访问一次

**缺点**：A 的位数限制了操作数的寻址范围，而且必须修改A的值，才能修改操作数的地址

---

##### 隐含寻址

指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中

 <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240326125334507.png" alt="image-20240326125334507" style="zoom:67%;" />  

由于隐含寻址在指令字中少了一个地址，因此，这种寻址方式的指令有利于缩短指令字长

---

##### 间接寻址

倘若指令字中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址，也就是说，有效地址是由形式地址间接提供的，即为间接寻址，即EA=（A)

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240326125446727.png" alt="image-20240326125446727" style="zoom:67%;" />   

**优点**：它扩大了操作数的寻址范围以及便于编程

**缺点**：在于指令的执行阶段需要访存两次（一次间接寻址）或多次（多次间接寻址)，致使指令执行时间延长

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240326125559265.png" alt=" " style="zoom:67%;" />  

---

##### 寄存器寻址

在寄存器寻址的指令字中，地址码字段直接指出了寄存器的编号，即EA=Ri

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240327124227915.png" alt="image-20240327124227915" style="zoom:67%;" />  

**优点**

- 操作数不在主存中，故寄存器寻址在指令执行阶段，无须访存，减少了执行时间
- 地址字段只需指明寄存器编号（计算机中寄存器数有限），故指令字较短，节省了存储空间

---

##### 寄存器间接寻址

Ri 中的内容不是操作数，而是操作数所在主存单元的地址号，即有效地址EA=(Ri)（有效地址不是存放在存储单元中，而是存放在寄存器中）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240327124329884.png" alt="image-20240327124329884" style="zoom:67%;" />   

---

##### 基址寻址

基址寻址需设有基址寄存器 BR，其操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容（称为基地址）相加，即 EA = A + (BR)

- 隐式：计算机内部专门设置一个基址寄存器 BR，使用时用户不必明显指出该基址寄存器
- 显式：一组通用的寄存器里，由用户来明确指出哪个寄存器用作基址寄存器

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240327124532788.png" alt="image-20240327124532788" style="zoom:67%;" />  

**优点**

- 基址寻址可以扩大操作数的寻址范围
- 基址寻址在多道程序中极为有用
- 用户也不可以修改基址寄存器的内容，确保系统安全可靠地运行

---

##### 变址寻址

变址寻址与基址寻址极为相似。其有效地址EA等于指令字中的形式地址A与变址寄存器 X的内容相加之和，即 EA = A +（IX)

变址寻址主要用于处理数组问题，在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器X的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240327125011238.png" alt="image-20240327125011238" style="zoom:67%;" />  

**优点**

- 只要变址寄存器位数足够，也可扩大操作数的寻址范围
- IX 的内容由用户给定
- 在程序执行过程中 IX 内容可变，形式地址A是不可变的
- 便于处理数组问题

---

##### 堆栈寻址

堆栈分为硬堆栈（多个寄存器）、软堆栈（指定的存储空间）

堆栈寻址就其本质也可视为寄存器间接寻址，因SP可视为寄存器，它存放着操作数的有效地址

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240327125542646.png" alt="image-20240327125542646" style="zoom:67%;" /> 



### RISC  和 CISC 技术

#### RISC 即精简指令系统计算机

主要特征：

- 选用使用频率较高的一些简单指令；复杂指令的功能由简单指令来组合实现
- 指令长度固定、指令格式种类少、寻址方式少
- 只有 LOAD/STORE 指令访存
- CPU 中有多个通用寄存器
- 采用流水技术，一个时钟周期内完成一条指令
- 采用组合逻辑实现控制器

#### CISC  即复杂指令系统计算机

主要特征：

- 系统指令复杂庞大，各种指令使用频度相差大
- 指令长度不固定、指令格式种类多、寻址方式多
- 访存指令不受限制
- CPU 中设有专有寄存器
- 大多数指令需要多个时钟周期执行完毕
- 采用微程序控制器

#### RISC 和 CISC 的比较

|                |       CISC       |        RISC        |
| :------------: | :--------------: | :----------------: |
|    指令系统    |    复杂，庞大    |     简单，精简     |
|    指令数目    |    大于200条     |     小于100条      |
|    指令字长    |      不固定      |        定长        |
|   可访存指令   |     不加限制     | 只有Load/Store指令 |
|    控制方式    | 绝大多数为微程序 | 绝大多数用组合逻辑 |
| 通用寄存器数量 |       较少       |         多         |

 



## CPU 的结构和功能

### CPU 概述

CPU实质包括运算器和控制器两大部分（运算器的功能上述已经介绍：实现算术运算以及逻辑运算），以控制器的功能为重点来讲述

#### 控制器概述

控制器负责协调并控制计算机各部件执行过程的指令序列，其基本功能是取指令、分析指令和执行指令

- 取指令
- 分析指令
- 执行指令。发出各种操作命令
- 控制程序输入以及结果的输出
- 总线管理
- 处理异常情况和特殊情况

#### CPU 框架图

- 寄存器用于存储当前指令的地址
- 控制器 CU 用于控制指令（获取分析以及执行）
- 运算器 ALU 用于完成算术运算以及逻辑运算
- 中断系统主要用于处理异常的情况以及特殊的请求

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240402125343002.png" alt=" " style="zoom: 80%;" /> 

#### CPU 寄存器                    

**用户可见寄存器**（通常CPU执行机器语言访问的寄存器为用户可见寄存器）         

- 通用寄存器

  通用寄存器可由程序设计者指定许多功能，可用于存放操作数，也可作为满足某种寻址方式所需的寄存器

- 数据寄存器

  存放操作数（满足各种数据类型）

- 地址寄存器

  存放地址，也可以用于特殊的寻址方式 段取值 栈指针

- 条件码寄存器

  存放条件码，可作程序分支的依据 如：正、负、零、溢出以及进位等

**控制和状态寄存器**（一类寄存器用于控制CPU的操作或运算）

- 控制寄存器

  PC -> MAR -> M -> MDR -> IR （除 PC 外，其他用户均不可见）

- 状态寄存器

  PSW 寄存器 （存放程序状态字）

#### 控制单元 CU

**CU 产生全部指令的微操作命令序列**

- 组合逻辑设计方法，为硬连线逻辑
- 微程序设计方法，为存储逻辑



### 指令周期

####  概述

**指令周期**：CPU 取出并执行一条指令所需要的全部时间

完成一条指令普遍需要：

- 取指、分析（取指周期）
- 执行 （执行周期）

**每条指令的指令周期不同**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240114165421391.png" alt="image-20240114165421391" style="zoom: 67%;" /> 

**带有中断周期的指令周期（复杂）**

指令周期流程：取值 -> 间接 -> 执行 -> 中断

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240114165642282.png" alt="image-20240114165642282" style="zoom:67%;" /> 

CPU的工作周期包括四个周期，分别是取值周期 - 间址周期 - 执行周期 - 中断周期，为了区别它们，在CPU内可设置4个标志触发器（状态 1  表示有效）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240407124351487.png" alt=" " style="zoom:80%;" />  

####   指令周期的数据流

1. **取指周期数据流**

   <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240114225644256.png" alt="image-20240114225644256" style="zoom:67%;" /> 

2. **间址周期数据流**

   前提：取指周期结束，CU 便检查 IR 中的内容，以确定其是否有间址操作，如果需要间址操作，则 MDR 中指示形式地址的右 N 位将被送到 MAR

   <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240114225828240.png" alt="image-20240114225828240" style="zoom:67%;" /> 

3. **执行周期数据流**

   差异较多，下面章节详解

4. **中断周期数据流**

   CPU 进入中断周期要完成一系列操作，其中 PC 当前的内容必须保存起来，以待执行完中断服务程序后可以准确返回到该程序的间断处

   <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240114230108919.png" alt="image-20240114230108919" style="zoom:67%;" /> 



### 指令流水

#### 概述

**如何提高机器速度？**

- 提高访存速度 (高速芯片、Cache等）
- 提高 I/O 和主机之间的传送速度（中断、DMA、通道、I/O处理机等）
- 提高运算器速度（高速芯片、改进算法、快速进位链等）
- 提高整机处理能力（高速器件、改进系统结构，开发系统的并行性等） 本章重点

**系统的并行性概念**

- 并发：两个或两个以上的事件在**同一时间段**发生
- 同时：两个或两个以上的事件在**同一时刻**发生（流水线方式）

**并行性的等级**

- 过程级（程序、进程） 粗粒度   软件实现
- 指令级（指令之间、指令内部）  细粒度   硬件实现

#### 指令流水的原理

**指令的串行执行**

取指令  取指令部件 ；执行指令  执行指令部件

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120110314920.png" alt="image-20240120110314920" style="zoom:67%;" /> 

**指令的二级流水**

取指和执行阶段事件上完全重叠，指令周期减半，速度提高一倍

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120111244761.png" alt="image-20240120111244761" style="zoom:67%;" /> 

**影响指令流水效率加倍的因素**

- 执行时间 > 取指时间

  取指令部件 ——> 指令部件缓冲区 ——>  执行指令部件

- 条件转移指令对指令流水的影响

  必须等上条指令执行结束，才能确定下条指令的地址造成时间的损失

**指令的六级流水**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120112103810.png" alt="image-20240120112103810" style="zoom:67%;" /> 

#### 影响流水线性能的因素

- **结构相关**  不同指令争用同一功能部件产生资源冲突

  解决方法：停顿、指令存储器和数据存储器分开、指令预取技术（适用于访存周期短的情况）

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120112428993.png" style="zoom:67%;" /> 

- **数据相关** 不同指令因重叠操作，可能改变操作数的读/写 访问顺序 

  解决办法：后推法（类似停顿）、采用旁路技术（不需要等待计算结果并写入到寄存器再读取，可以等计算出结果则可以读取该数据）

  - 写后读相关（RAW）

    需要读取到写之后的寄存器里的数据

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120114140091.png" alt="image-20240120114140091" style="zoom:67%;" /> 

  - 读后写相关（WAR）

    需要读取到写之前的寄存器的数据

  - 写后写相关（WAW）

- **控制相关** 有指令转移引起（类似于条件判断）

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120115326662.png" alt="image-20240120115326662" style="zoom:67%;" /> 

#### 流水线的性能

- **吞吐率** 

  单位时间内流水线所完成指令或者输出结果的数量

  对于m段的指令流水线而言，若各段的时间均为 △t 的情况

  - 最大吞吐率

    ![](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120115550268.png) 

  - 实际吞吐率

    连续处理 n 条指令的吞吐率

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120115723738.png" alt="image-20240120115723738" style="zoom:80%;" /> 

- **加速比 Sp**

  m 段的流水线的速度与等功能的非流水线的速度之比

  - 设流水线隔断时间为 △t ，完成 n 条指令在 m 段流水线共需时间

    ![image-20240120120043130](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120120043130.png) 

  - 完成 n 条指令在等效的非流水线上的共需要时间

    T = nm* △t 

  - 因此加速度比 Sp 求得如下

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120120107104.png" alt="image-20240120120107104" style="zoom:80%;" /> 

- **效率**

  流水线中各功能段的利用率

  效率 = 流水线各段处于工作时间的时空区 / 流水段中各段总的时空区

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120120721200.png" alt="image-20240120120721200" style="zoom:67%;" /> 

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120120520171.png" alt="image-20240120120520171" style="zoom:67%;" /> 

#### 流水线的多发技术

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120121412826.png" alt="image-20240120121412826" style="zoom:80%;" /> 

- 超标量技术

  - 每个时钟周期内可 并发多条独立指令：配置多个功能部件
  - 不能调整指令的执行顺序：通过编译优化技术，把可并行执行的指令搭配起来

- 超流水线技术

  在同一个时钟周期内再分段，但是依旧不能调整指令的执行顺序

- 超长指令字技术

  由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位）

#### 流水线结构

- **指令流水线结构**

  完成一条指令分成6段，每段需要一个时钟周期，并且每个段之间需要加上锁存（用于保存前面流水段的操作结果以及为下面的流水提供操作数据等功能）

  ![](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120122020045.png) 

- **运算流水线**

  完成浮点加减法运算可分为 对阶、尾数求和、规格化三段

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240120122421698.png" alt="image-20240120122421698" style="zoom:80%;" />  



### 中断系统

#### 概述

**引起中断的各种因素**

- 人为设置的各种因素，如：转管指令（通常出现在流水线处理器的上下文中，它们是用来控制流水线操作的一组指令）

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127110222536.png" alt="image-20240127110222536" style="zoom:80%;" /> 

- 程序性事故，如溢出、操作码等由于程序设计不周导致的

- 硬件故障，如电源掉电

- I/O设备（I/O设备被启动以后，一旦准备就绪，便向CPU发出中断请求）

- 外部事件，如**键盘中断**现行程序

---

#### 中断请求标记和中断判优逻辑

##### 中断请求标记 INTR

**各中断源如何向 CPU 提出请求？**

一个请求源对应一个中断请求标志触发器，如果有多个中断请求标记，将会组成中断请求标记寄存器，如下图

中断请求标记触发器有的是集中在 CPU 的中断系统内，也有的是分散在各个中断源的接口电路中

![image-20240127112302902](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127112302902.png) 

中断请求触发器越多，说明计算机处理中断的能力越强

---

##### 中断判优逻辑

**各中断源如果同时向 CPU 提出请求怎么办？**

- 硬件实现（排队器）

  - 分散在各个中断源的接口电路中 （链式排队器）

  - 集中在 CPU 内部

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127113328565.png" alt="image-20240127113328565" style="zoom:67%;" /> 

- 软件实现 （程序查询）

  编写代码实现查询中断服务程序

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127113850201.png" alt="image-20240127113850201" style="zoom:67%;" /> 

---

#### 中断服务程序入口地址查询

**如何寻找中断服务执行入口地址？**

通常有两种方法寻找入口地址：硬件向量法和软件查询法

##### 硬件向量法

1. 输入：排队器的输出 ；输出：中断向量地址

   ![image-20240127114327506](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127114327506.png)  

2. 通过输出的向量地址，再如下的中断向量地址表里去查询中断服务程序入口地址

   <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127114442285.png" alt="image-20240127114442285" style="zoom:80%;" /> 

##### 软件查询法

- 用软件寻找中断服务程序入口地址的方法称为软件查询法，框图类似中断判优逻辑的软件实现
- 相比于硬件向量法，软件查询查询时间长，但是方便用户使用更加灵活

---

#### 中断响应

**CPU 在什么情况下以各种方式来响应中断？**

##### 响应中断的条件

- 响应中断条件：允许中断触发器 EINT = 1

- 响应中断的时间：**指令执行周期结束时刻**由 CPU 发出查询条件

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240127115908258.png" alt="image-20240127115908258" style="zoom:67%;" /> 

- 中断隐指令

  所谓中断隐指令，即在机器指令系统中没有的指令，它是CPU在中断周期内由硬件自动完成的一条指令

  - 保存程序断点：断点存于特定地址内 ； 断点进栈

  - 寻找服务程序入口地址（如上）

  - 硬件关中断（防止其他优先级低的中断请求打断当前的中断）

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128114828345.png" alt="image-20240128114828345" style="zoom:80%;" /> 

---

#### 保护现场和恢复现场

保护现场和恢复现场是CPU在中断处理过程中采取的操作，通常用于单片机和嵌入式系统

**如何保护现场？**

- 保护断点： 中断隐指令完成如上
- 保护CPU内部各寄存器内容： 中断服务程序完成

**中断服务程序的四个步骤**

- 保护现场 PUSH （保存在堆栈中）
- 其他服务程序 视不同请求源而定
- 恢复现场 POP
- 中断返回 IRET

**如何恢复现场？**

恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作也由中断服务程序完成如上

---

#### 多重中断

##### 概述

当CPU正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而CPU又响应了这个新的请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序，这称为多重中断，又称中断嵌套

![image-20240128120130034](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128120130034.png) 

##### 实现多重中断的条件

- 提前设置开中断指令

- 优先级别高的中断源有权中断优先级别低的中断源

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128120734528.png" alt="image-20240128120734528" style="zoom: 67%;" /> 

##### 屏蔽技术和屏蔽字

**屏蔽技术**

作用：使某个中断源无法向 CPU 提出中断请求，也不能参加中断优先级排队器

触发器 D、中断请求触发器 INTR、 屏蔽触发器 MASK

如果排队器集中设在 CPU 内，加上屏蔽条件，就可组成具有屏蔽功能的排队器如下图

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128122848111.png" alt="image-20240128122848111" style="zoom:80%;" /> 

**屏蔽字**

对应每个中断请求触发器就有一个屏蔽触发器，将所有屏蔽触发器组合在一起，便构成一个屏蔽寄存器，屏蔽寄存器的内容称为屏蔽字

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128150151276.png" alt="image-20240128150151276" style="zoom: 67%;" /> 

**屏蔽技术可以改变改变处理优先级等级**

优先级包含响应优先级和处理优先级

- 响应优先级是指 CPU 响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动
- 处理优先级是指 CPU 实际对各中断源请求的处理优先次序（如果不采用屏蔽技术，响应的优先次序就是处理的优先次序）

修改屏蔽字前后的变化

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128150903024.png" alt="image-20240128150903024" style="zoom:67%;" /> 

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128150748209.png" alt="image-20240128150748209" style="zoom: 50%;" />  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128150810479.png" alt="image-20240128150810479" style="zoom:50%;" /> 

**新屏蔽字的设置**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240128151421638.png" alt="image-20240128151421638" style="zoom:50%;" />  

##### 多重中断的断点保护

多重中断时，每次中断出现的断点都必须保存起来

- 断点可以保存在堆栈中，由于堆栈先进后出的特点，实现对断点的保存和恢复
- 断点也可保存在特定的存储单元内，在中断服务程序中的开中断指令之前，必须先将 0地址单元的内容转存至其他地址单元中，才能真正保存每一个断点



## 控制单元的功能

### 微操作命令分析

完成一条指令分四个周期：取指周期、间址周期、执行周期、中端周期

#### 取指周期

1. **指令地址计算**：CPU 根据程序计数器 PC 中的值计算下一条指令的地址。程序计数器存储着当前正在执行的指令的地址或者下一条要执行的指令的地址
2. **访问内存**：CPU根据计算得到的指令地址，向主存发送请求，读取下一条指令所在的内存单元
3. **指令译码**：CPU对从内存中读取的指令进行译码，确定指令的操作类型、操作数等信息
4. **指令存储**：将从内存中读取的指令存储到指令寄存器 IR 中，供接下来的执行阶段使用

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240222213033228.png" alt="image-20240222213033228" style="zoom:80%;" />  

#### 间址周期

在间接寻址中，指令不直接提供操作数的地址，而是提供一个指向操作数地址的指针（IR 分析出的是操作数的地址）

![image-20240222215217236](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240222215217236.png) 

#### 执行周期

**非访存指令**

- 清除累加器指令 CLA （0 => A）
- 累加器取反指令 COM
- 算术右移一位指令 SHR（L(ACC) => R(ACC)）
- 循环左移一位指令 CSL（R(ACC) => L(ACC)）
- 停机指令STP（0 => G）

**访存指令**

- 加法指令 ADD  X
  1. 将指令的地址码部分送至存储器地址寄存器（Ad(IR)→MAR）
  2. 向主存发读命令，启动主存作读操作（1→R）
  3. 将MAR(通过地址总线)所指的主存单元中的内容（操作数）经数据总线读至MDR内（M(MAR)→MDR）
  4. 给ALU发送加命令，将ACC的内容和MDR的内容相加，结果存于ACC（(ACC)+(MDR)+ACC)）
- 存数指令 STA  X
  1. 将指令的地址码部分送至存储器地址寄存器（Ad(IR)→MAR）
  2. 向主存发写命令，启动主存作写操作（1→W）
  3. 将累加器内容送至MDR（ACC-→MDR）
  4. 将MDR的内容（通过数据总线）写入到MAR(通过地址总线)所指的主存单元中（MDR+M(MAR)）
- 取数指令 LDA  X
  1. 将指令的地址码部分送至存储器地址寄存器（Ad(IR)→MAR）
  2. 向主存发读命令，启动主存作读操作（1→R）
  3. 将MAR(通过地址总线)所指的主存单元中的内容（操作数）经数据总线读至MDR内（M(MAR)+MDR）
  4. 将MDR的内容送至ACC（MDR+ACC）

**转移类指令**

- 无条件转移指令 JMP  X
- 条件转移指令 BAN  X（负则转）

**三类指令的指令周期**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240222221017973.png" alt="image-20240222221017973" style="zoom:80%;" />  

#### 中断周期

- 保存断点

  - 程序断点存入 “0” 地址

    - 将特定地址 “0”送至存储器地址寄存器（0→MAR）
    - 向主存发写命令，启动存储器作写操作 （1→W）
    - 将PC的内容（程序断点）送至 MDR（PC→MDR）
    - 将MDR的内容（程序断点）通过数据总线写入到MAR(通过地址总线)所指示的主存单元( “0”地址单元)中（MDR→M(MAR)）
    - 将向量地址形成部件的输出送至PC，为下一条指令的取指周期作推备（向量地址→PC）
    - 关中断，将允许中断触发器清零（0→ET）

  - 程序断点进栈

    如果程序断点存入堆栈，而且进栈操作是先修改栈指针，后存入数据，只需将上述第一个改为 (SP)-1→MAR




### 控制单元的功能 

#### 控制单元的外特性

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303134233976.png" alt="image-20240303134233976" style="zoom:80%;" /> 

##### 输入信号

- **时钟** （CU 受时钟控制）

  一个时钟脉冲，会发送一个操作命令或者一组需同时执行的操作命令

- **指令寄存器** （OP(IR) -> CU）

  控制信号与操作码有关，现行指令的操作码决定了不同指令在执行周期所需完成的不同操作

- **标志**

  控制单元有时需依赖CPU当前所处的状态（如ALU操作的结果）产生控制信号

- **外来信号**（如 INTR 中断请求 HRQ 总线请求）

##### 输出信号

- CPU 内的各种控制信号（PC + 1 -> PC）
- 送至控制总线的信号（访存控制信号、读写命令等）

#### 控制信号举例

##### 不采用CPU内部总线的方式

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303140009475.png" alt="image-20240303140009475" style="zoom:80%;" /> 

###### 取指周期

- 控制信号C0 有效，打开PC送往MAR的控制门
- 控制信号C1有效，打开MAR送往地址总线的输出门
- 通过控制总线向主存发读命令
- C2有效，打开数据总线送至MDR的输入门
- C3有效，打开MDR和IR之间的控制门，至此指令送至IR
- C4有效，打开指令操作码送至CU的输出门。CU在操作码和时钟的控制下，可产生各种控制信号
- 使PC内容加1

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303140501860.png" alt="image-20240303140501860" style="zoom:80%;" /> 

###### 间址周期

- C5有效，打开MDR和MAR之间的控制门，将指令的形式地址送至MAR
- C1有效，打开MAR送往地址总线的输出门
- 通过控制总线向主存发读命令
- C2有效，打开数据总线送至MDR的输入门，至此，有效地址存入MDR
- C3有效，打开MDR和IR之间的控制门，将有效地址送至IR的地址码字段

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303141153702.png" alt="image-20240303141153702" style="zoom:80%;" /> 

###### 执行周期

- C5有效，打开MDR和MAR之间的控制门，将有效地址送至MAR
- C1有效，打开MAR送往地址总线的输出门
- 通过控制总线向主存发读命令
- C2有效，打开数据总线送至MDR的输入门，至此，操作数存入MDR
- C6、C7同时有效，打开AC和MDR通往ALU的控制门
- 通过CPU内部控制总线对ALU发**ADD**加控制信号，完成AC的内容和MDR的内容相加
- C8有效，打开ALU通往AC的控制门，至此将求和结果存入AC

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303143224134.png" alt="image-20240303143224134" style="zoom:80%;" /> 

##### 采用CPU内部总线的方式

采用CPU内部总线方式的数据通路和控制信号的关系，图中每一个小圈处都有一个控制信号，它控制寄存器到总线或总线到寄存器之间的传送

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303143901686.png" alt=" " style="zoom:80%;" />  

###### 取指周期

- PC0和MAR有效，完成PC经内部总线送至MAR的操作，即PC → MAR
- 通过控制总线向主存发读命令，即1 → R
- 存储器通过数据总线将MAR所指单元的内容（指令）送至MDR
- MDR0和IRi有效，将MDR的内容送至IR,即MDR→IR,至此，指令送至IR,其操作码字段开始控制CU
- 使PC内容加1

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303144831731.png" alt="image-20240303144831731" style="zoom:80%;" /> 

###### 间址周期

- MDR0和MARi有效，将指令的形式地址经内部总线送至MAR,即MDR → MAR
- 通过控制总线向主存发读命令，即1 → R
- 存储器通过数据总线将MAR所指单元的内容（有效地址）送至MDR
- MDR0和IRi有效，将MDR中的有效地址送至IR的地址码字段，即MDR → Ad(IR)

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303145248108.png" alt="image-20240303145248108" style="zoom:80%;" /> 

###### 执行周期

- MDR0和MARi有效，将有效地址经内部总线送至MAR,即MDR → MAR
- 通过控制总线向主存发读命令，即1 → R
- 存储器通过数据总线将MAR所指单元的内容（操作数）送至MDR
- MDR0和Yi有效，将操作数送至Y,即MDR → Y
- AC0和ALUi有效，同时CU向ALU发**ADD**加控制信号，使AC的内容和Y的内容相加(Y的内容送至ALU不必通过总线)，结果送寄存器Z即（AC)+（Y) → Z
- Z0和ACi有效，将运算结果存入AC,即Z → AC

 <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303145615903.png" alt="image-20240303145615903" style="zoom:80%;" /> 

#### 多级时序系统

##### 机器周期

**概念**：所有指令执行过程中的一个基准时间

**确认机器周期需要考虑的因素**：每条指令的执行步骤以及每一步骤所需的时间

**基准时间的确定**：若指令字长 = 存储字长 取指周期 = 机器周期

- 以完成最复杂指令功能的时间为准
- 以访问一次存储器的时间为基准

##### 时钟周期

一个机器周期内可完成若干个微操作（将一个机器周期分成若干个时间相等的时间端，分别是节拍、状态、时钟周期）

时钟周期是控制计算机操作的最小单位时间（用时钟周期产生一个或几个微操作指令）

图中时钟周期、机器周期以及一个机器周期内有4个节拍T0、T1、T2、T3

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303150731174.png" alt="image-20240303150731174" style="zoom:67%;" /> 

##### 多级时序系统

机器周期、节拍（状态）组成多级时序系统

- 一个指令周期包含若干机器周期
- 一个机器周期包含若个时钟周期

![image-20240303151231024](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303151231024.png) 

##### 机器速度和机器主频的关系

机器速度不仅与主频有关，还与机器周期中所含时钟周期（主频的倒数）数以及指令周期所含的机器周期数有关

##### 控制方式

- **同步控制方式**：任一微操作均由统一基准时标的时序信号控制

  - **采用定长的机器周期**：以最长的微操作序列和最复杂的微操作作为标准

  - **采用不定长的机器周期**：机器周期内的节拍数不等

    解决微操作执行时间不统一的问题。通常把大多数微操作安排在一个较短的机器周期内完成，而对某些复杂的微操作，采用延长机器周期或增加节拍的办法来解决

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303151832504.png" alt="image-20240303151832504" style="zoom:67%;" /> 

  - **采用中央控制和局部控制相结合的方法**：种将机器的大部分指令安排在统一的、较短的机器周期内完成，称为中央控制，而将
    少数操作复杂的指令中的某些操作（如乘除法和浮点运算等）采用局部控制方式来完成

    <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240303152241518.png" alt="image-20240303152241518" style="zoom:67%;" /> 

- **异步控制方式**：无基准时标信号，无固定的周期节拍和严格的时钟同步，采用应答方式

- **联合控制方式**：同步和异步结合

- **人工控制方式**：为了调机和软件开发的需要，在机器面板或内部设置一些开关或按键，来达到人机控制的目的



## 控制单元的设计

暂不学习







